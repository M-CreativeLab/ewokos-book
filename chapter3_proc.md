# 第三章：幕后黑手 - 进程与线程

## 3.1 什么是进程？

如果 CPU 是一个做菜的厨师，**进程 (Process)** 就是一道正在做的菜。
*   **代码**：菜谱。
*   **数据**：食材。
*   **堆栈**：切菜板和锅。
*   **PC 指针**：厨师读到了菜谱的哪一行。

在 EwokOS 中，进程是资源分配的最小单位。每个进程都有自己独立的厨房（内存空间），互不干扰。

## 3.2 进程的档案袋：`proc_t`

内核怎么管理这么多进程呢？它给每个进程都建了一个档案袋，叫做 `proc_t`。
你可以在 `kernel/kernel/include/kernel/proc.h` 里找到它的定义。

```c
typedef struct st_proc {
    procinfo_t        info;           // 1. 基本信息
    proc_space_t*     space;          // 2. 领地（内存空间）
    context_t         ctx;            // 3. 案发现场（上下文）
    int64_t           sleep_counter;  // 4. 睡眠时间
    // ... 其他字段
} proc_t;
```

让我们打开这个档案袋看看：

1.  **`info` (基本信息)**：
    *   **PID**：身份证号，从 0 开始递增分配。
    *   **State**：状态。是正在切菜（`RUNNING`），还是在等菜送来（`BLOCK`、`WAIT`），还是已经做完了（`ZOMBIE`），或者准备好了（`READY`）。
    *   **Owner**：谁点的菜（父进程 PPID）。
    *   **Priority**：优先级。数字越小，优先级越高。
    *   **Core ID**：在多核系统中，标识进程运行在哪个 CPU 核心上。

2.  **`space` (领地)**：
    *   这里记录了进程拥有哪些内存页表。就像房产证一样，证明这块内存是我的，别人不能乱动。
    *   包含页目录 (`page_dir_entry_t* vm`) 的指针。
    *   包含堆 (`heap`) 和栈 (`stack`) 的范围。
    *   `COW` 标记：标识哪些页面是写时复制的共享页面。

3.  **`ctx` (案发现场)**：
    *   这是最关键的部分！当厨师（CPU）要暂停做这道菜去处理别的事情时，他必须把当前的进度（寄存器值）记下来。
    *   `pc` (Program Counter)：读到哪一行了（下一条要执行的指令地址）。
    *   `sp` (Stack Pointer)：锅里有什么（栈顶指针）。
    *   `lr` (Link Register)：记住从哪里来，回去的地址。
    *   `r0-r12`：ARM 通用寄存器，保存运算数据。
    *   `cpsr`：当前程序状态寄存器，包含条件标志位。

4.  **`sleep_counter` (睡眠计数器)**：
    *   当进程调用 `sleep()` 时，这个计数器记录还需要睡多少个时钟周期。
    *   每次时钟中断时，内核会递减所有睡眠进程的计数器。
    *   当计数器归零时，进程被唤醒。

## 3.2.1 进程状态转换图

```
       fork()
   NEW -------> READY --------+
                  ^            |
                  |  schedule()|
              wakeup()         v
   WAIT/BLOCK <--------- RUNNING -----> ZOMBIE ----> (销毁)
      ^                     |              ^
      |  sleep()/           |              |
      +-- ipc_call()        +-- exit() ----+
```

## 3.3 调度：谁是下一个幸运儿？

EwokOS 的调度器 (Scheduler) 就像一个发号员。它的工作很简单：**决定下一个让谁用 CPU**。

EwokOS 使用的是**优先级调度**算法。
1.  **就绪队列**：所有准备好运行的进程都在这里排队。
2.  **Tick**：时钟每隔一段时间（比如 10ms）就会滴答一下，提醒调度器：“该换人了！”
3.  **挑选**：调度器看一眼队列，挑一个优先级最高的进程。
4.  **切换**：把当前进程踢下去，把新进程换上来。

**关键代码片段** (`kernel/kernel/src/sched.c`)：
```c
void schedule(context_t* ctx) {
    // 1. 保存当前进程的上下文
    if(_current_proc != NULL)
        proc_save(ctx);
    
    // 2. 从就绪队列选择下一个进程
    _current_proc = proc_get_next_ready();
    
    // 3. 如果没有就绪进程，运行空闲进程
    if(_current_proc == NULL)
        _current_proc = _idle_proc;
    
    // 4. 加载新进程的上下文
    proc_load(ctx);
}
```

### 多核调度 (SMP Scheduling)

在多核系统中，每个 CPU 核心都有自己的调度器。EwokOS 实现了**负载均衡**：
*   每个核心维护自己的就绪队列。
*   当某个核心空闲时，可以从其他核心的队列"偷"进程来执行（**Work Stealing**）。
*   进程可以被"亲和"到特定核心，提高缓存命中率。

**多核调度的挑战**：
*   **临界区保护**：多个核心可能同时访问调度器数据结构，需要使用自旋锁 (Spinlock)。
*   **核间中断 (IPI)**：一个核心可以向其他核心发送中断，通知它们重新调度。

## 3.4 上下文切换：魔术般的瞬间

**上下文切换 (Context Switch)** 是操作系统最迷人的魔术。
当 CPU 从进程 A 切换到进程 B 时，发生了什么？

1.  **冻结 A**：把 A 的所有寄存器值（案发现场）保存到 A 的 `proc_t->ctx` 里。
2.  **加载 B**：从 B 的 `proc_t->ctx` 里读出寄存器值，填回 CPU。
3.  **继续**：CPU 指针指向 B 上次停下的地方，继续执行。

对进程 A 来说，它感觉自己只是眨了一下眼（虽然可能过了几百毫秒），世界就变了。

## 3.5 线程：轻量级的进程

如果进程是“一道菜”，**线程 (Thread)** 就是“这道菜里的不同工序”。
*   洗菜、切菜、炒菜可以同时进行（如果有多核 CPU）。
*   它们共享同一个厨房（内存空间）。
*   它们共享同一份食材（全局变量）。

在 EwokOS 中，线程被视为“共享地址空间的进程”。它们有自己的 `ctx` 和栈，但共用 `space`。

下一章，我们将看看这些独立的进程是如何“打电话”沟通的。
