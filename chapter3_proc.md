# 第三章：幕后黑手 - 进程与线程

在上一章中，我们从架构层面理解了 EwokOS 的整体设计。现在，让我们深入系统的"心脏"——进程管理。这是操作系统最核心、最迷人的部分。如果没有进程管理，再强大的硬件也只能像一个傻瓜一样，一次只做一件事。

## 3.1 什么是进程？

如果 CPU 是一个做菜的厨师，**进程 (Process)** 就是一道正在做的菜。
*   **代码**：菜谱。
*   **数据**：食材。
*   **堆栈**：切菜板和锅。
*   **PC 指针**：厨师读到了菜谱的哪一行。

在 EwokOS 中，进程是资源分配的最小单位。每个进程都有自己独立的厨房（内存空间），互不干扰。

### 进程的诞生：Unix 的革命性创新

进程的概念看似简单，但它的发明却是计算机历史上的一次重大突破。

在 Unix 诞生之前（1960 年代），大多数操作系统使用的是**作业 (Job)** 的概念。一个作业从开始到结束，独占整个计算机。想要同时运行多个程序？你需要等第一个跑完，或者买更多计算机。

1969 年，Ken Thompson 和 Dennis Ritchie 在开发 Unix 时，创造性地引入了**进程抽象**。他们的核心洞察是：**让每个程序都以为自己独占了整个计算机，但实际上操作系统在幕后快速切换**。这就像魔术师的手法——观众看到的是连续的动作，实际上是一系列快速的离散操作。

这个设计如此成功，以至于 50 多年后的今天，几乎所有操作系统（包括 Windows、Linux、macOS、iOS、Android）都沿用了这个抽象。EwokOS 也不例外。

## 3.2 进程的档案袋：`proc_t`

内核怎么管理这么多进程呢？它给每个进程都建了一个档案袋，叫做 `proc_t`。
你可以在 `kernel/kernel/include/kernel/proc.h` 里找到它的定义。

```c
typedef struct st_proc {
    procinfo_t        info;           // 1. 基本信息
    proc_space_t*     space;          // 2. 领地（内存空间）
    context_t         ctx;            // 3. 案发现场（上下文）
    int64_t           sleep_counter;  // 4. 睡眠时间
    // ... 其他字段
} proc_t;
```

让我们打开这个档案袋看看：

1.  **`info` (基本信息)**：
    *   **PID**：身份证号，从 0 开始递增分配。
    *   **State**：状态。是正在切菜（`RUNNING`），还是在等菜送来（`BLOCK`、`WAIT`），还是已经做完了（`ZOMBIE`），或者准备好了（`READY`）。
    *   **Owner**：谁点的菜（父进程 PPID）。
    *   **Priority**：优先级。数字越小，优先级越高。
    *   **Core ID**：在多核系统中，标识进程运行在哪个 CPU 核心上。

2.  **`space` (领地)**：
    *   这里记录了进程拥有哪些内存页表。就像房产证一样，证明这块内存是我的，别人不能乱动。
    *   包含页目录 (`page_dir_entry_t* vm`) 的指针。
    *   包含堆 (`heap`) 和栈 (`stack`) 的范围。
    *   `COW` 标记：标识哪些页面是写时复制的共享页面。

3.  **`ctx` (案发现场)**：
    *   这是最关键的部分！当厨师（CPU）要暂停做这道菜去处理别的事情时，他必须把当前的进度（寄存器值）记下来。
    *   `pc` (Program Counter)：读到哪一行了（下一条要执行的指令地址）。
    *   `sp` (Stack Pointer)：锅里有什么（栈顶指针）。
    *   `lr` (Link Register)：记住从哪里来，回去的地址。
    *   `r0-r12`：ARM 通用寄存器，保存运算数据。
    *   `cpsr`：当前程序状态寄存器，包含条件标志位。

4.  **`sleep_counter` (睡眠计数器)**：
    *   当进程调用 `sleep()` 时，这个计数器记录还需要睡多少个时钟周期。
    *   每次时钟中断时，内核会递减所有睡眠进程的计数器。
    *   当计数器归零时，进程被唤醒。

## 3.2.1 进程状态转换图

```
       fork()
   NEW -------> READY --------+
                  ^            |
                  |  schedule()|
              wakeup()         v
   WAIT/BLOCK <--------- RUNNING -----> ZOMBIE ----> (销毁)
      ^                     |              ^
      |  sleep()/           |              |
      +-- ipc_call()        +-- exit() ----+
```

## 3.3 调度：谁是下一个幸运儿？

EwokOS 的调度器 (Scheduler) 就像一个发号员。它的工作很简单：**决定下一个让谁用 CPU**。

EwokOS 使用的是**优先级调度**算法。
1.  **就绪队列**：所有准备好运行的进程都在这里排队。
2.  **Tick**：时钟每隔一段时间（比如 10ms）就会滴答一下，提醒调度器：“该换人了！”
3.  **挑选**：调度器看一眼队列，挑一个优先级最高的进程。
4.  **切换**：把当前进程踢下去，把新进程换上来。

**关键代码片段** (`kernel/kernel/src/sched.c`)：
```c
void schedule(context_t* ctx) {
    // 1. 保存当前进程的上下文
    if(_current_proc != NULL)
        proc_save(ctx);
    
    // 2. 从就绪队列选择下一个进程
    _current_proc = proc_get_next_ready();
    
    // 3. 如果没有就绪进程，运行空闲进程
    if(_current_proc == NULL)
        _current_proc = _idle_proc;
    
    // 4. 加载新进程的上下文
    proc_load(ctx);
}
```

### 调度算法的演变：从简单到复杂

让我们看看调度算法是如何演化的：

**1. 先来先服务 (FCFS, First-Come-First-Served)**
*   最简单的算法：谁先到谁先执行。
*   问题：如果第一个进程需要运行 1 小时，后面的进程就要等 1 小时。这就是著名的**护航效应 (Convoy Effect)**。

**2. 时间片轮转 (Round Robin)**
*   每个进程分配固定的时间片（如 10ms），时间到了就轮换。
*   这是早期分时系统（1960 年代）的标准算法。
*   问题：所有进程都是平等的，没有优先级区分。

**3. 优先级调度 (Priority Scheduling)**
*   EwokOS 使用的算法。每个进程有优先级，高优先级优先执行。
*   问题：低优先级进程可能**饿死 (Starvation)**——永远得不到执行。
*   解决方案：**优先级老化 (Aging)**——等待时间越长，优先级逐渐提升。

**4. 完全公平调度器 (CFS, Completely Fair Scheduler)**
*   Linux 2.6.23（2007 年）引入的现代调度器。
*   使用红黑树跟踪每个进程的"虚拟运行时间"，确保所有进程获得公平的 CPU 时间。
*   这是目前最先进的通用调度算法之一。

EwokOS 选择了优先级调度，因为它简单、高效，非常适合嵌入式系统和实时应用。对于学习来说，也更容易理解。

### 多核调度 (SMP Scheduling)

在多核系统中，每个 CPU 核心都有自己的调度器。EwokOS 实现了**负载均衡**：
*   每个核心维护自己的就绪队列。
*   当某个核心空闲时，可以从其他核心的队列"偷"进程来执行（**Work Stealing**）。
*   进程可以被"亲和"到特定核心，提高缓存命中率。

**多核调度的挑战**：
*   **临界区保护**：多个核心可能同时访问调度器数据结构，需要使用自旋锁 (Spinlock)。
*   **核间中断 (IPI)**：一个核心可以向其他核心发送中断，通知它们重新调度。

## 3.4 上下文切换：魔术般的瞬间

**上下文切换 (Context Switch)** 是操作系统最迷人的魔术。
当 CPU 从进程 A 切换到进程 B 时，发生了什么？

1.  **冻结 A**：把 A 的所有寄存器值（案发现场）保存到 A 的 `proc_t->ctx` 里。
2.  **加载 B**：从 B 的 `proc_t->ctx` 里读出寄存器值，填回 CPU。
3.  **继续**：CPU 指针指向 B 上次停下的地方，继续执行。

对进程 A 来说，它感觉自己只是眨了一下眼（虽然可能过了几百毫秒），世界就变了。

## 3.5 线程：轻量级的进程

如果进程是“一道菜”，**线程 (Thread)** 就是“这道菜里的不同工序”。
*   洗菜、切菜、炒菜可以同时进行（如果有多核 CPU）。
*   它们共享同一个厨房（内存空间）。
*   它们共享同一份食材（全局变量）。

在 EwokOS 中，线程被视为“共享地址空间的进程”。它们有自己的 `ctx` 和栈，但共用 `space`。

下一章，我们将看看这些独立的进程是如何“打电话”沟通的。

## 3.6 本章小结与展望

我们刚刚完成了一次深入操作系统心脏的旅程。让我们回顾一下学到的核心概念：

*   **进程抽象**：Unix 在 1969 年发明的革命性概念，让多个程序可以"同时"运行在单个 CPU 上
*   **进程状态**：从 NEW 到 READY，再到 RUNNING、WAIT/BLOCK，最后到 ZOMBIE，每个进程都经历着生命周期
*   **调度算法**：从最简单的 FCFS 到现代的 CFS，操作系统一直在追求更公平、更高效的 CPU 分配
*   **多核挑战**：如何让多个 CPU 核心高效协作而不互相干扰，这是现代操作系统必须面对的难题

但这里有一个关键问题我们还没有回答：在微内核架构中，所有的服务（VFS、驱动等）都是独立的进程，它们有自己独立的内存空间。那么，**Shell 如何告诉 VFS"我要读取文件"？驱动如何把数据返回给应用程序？**

在宏内核中，这很简单——大家都在同一个内存空间，直接调用函数就行了。但在微内核中，进程之间是完全隔离的，不能直接访问对方的内存。这就需要一个特殊的机制来传递消息和数据。

**这就是下一章的主题——IPC（进程间通信）**。我们将看到：
*   微内核如何像一个高效的邮局，在进程之间传递消息
*   同步 IPC 和异步 IPC 的区别——打电话 vs 发邮件
*   共享内存如何实现零拷贝的高效数据传输
*   IPC 如何成为微内核架构的"神经系统"

## 3.6 本章小结与展望

我们刚刚完成了一次深入操作系统心脏的旅程。让我们回顾一下学到的核心概念：

*   **进程抽象**：Unix 在 1969 年发明的革命性概念，让多个程序可以"同时"运行在单个 CPU 上
*   **进程状态**：从 NEW 到 READY，再到 RUNNING、WAIT/BLOCK，最后到 ZOMBIE，每个进程都经历着生命周期
*   **调度算法**：从最简单的 FCFS 到现代的 CFS，操作系统一直在追求更公平、更高效的 CPU 分配
*   **多核挑战**：如何让多个 CPU 核心高效协作而不互相干扰，这是现代操作系统必须面对的难题

但这里有一个关键问题我们还没有回答：在微内核架构中，所有的服务（VFS、驱动等）都是独立的进程，它们有自己独立的内存空间。那么，**Shell 如何告诉 VFS"我要读取文件"？驱动如何把数据返回给应用程序？**

在宏内核中，这很简单——大家都在同一个内存空间，直接调用函数就行了。但在微内核中，进程之间是完全隔离的，不能直接访问对方的内存。这就需要一个特殊的机制来传递消息和数据。

**这就是下一章的主题——IPC（进程间通信）**。我们将看到：
*   微内核如何像一个高效的邮局，在进程之间传递消息
*   同步 IPC 和异步 IPC 的区别——打电话 vs 发邮件
*   共享内存如何实现零拷贝的高效数据传输
*   IPC 如何成为微内核架构的"神经系统"

进程管理解决了"谁来用 CPU"的问题，而 IPC 将解决"进程之间如何协作"的问题。让我们继续探索。
