# 第三章：幕后黑手 - 进程与线程

## 3.1 什么是进程？

如果 CPU 是一个做菜的厨师，**进程 (Process)** 就是一道正在做的菜。
*   **代码**：菜谱。
*   **数据**：食材。
*   **堆栈**：切菜板和锅。
*   **PC 指针**：厨师读到了菜谱的哪一行。

在 EwokOS 中，进程是资源分配的最小单位。每个进程都有自己独立的厨房（内存空间），互不干扰。

## 3.2 进程的档案袋：`proc_t`

内核怎么管理这么多进程呢？它给每个进程都建了一个档案袋，叫做 `proc_t`。
你可以在 `kernel/kernel/include/kernel/proc.h` 里找到它的定义。

```c
typedef struct st_proc {
    procinfo_t        info;           // 1. 基本信息
    proc_space_t*     space;          // 2. 领地（内存空间）
    context_t         ctx;            // 3. 案发现场（上下文）
    int64_t           sleep_counter;  // 4. 睡眠时间
    // ... 其他字段
} proc_t;
```

让我们打开这个档案袋看看：

1.  **`info` (基本信息)**：
    *   **PID**：身份证号。
    *   **State**：状态。是正在切菜（运行），还是在等菜送来（阻塞），还是已经做完了（僵尸）。
    *   **Owner**：谁点的菜（父进程）。

2.  **`space` (领地)**：
    *   这里记录了进程拥有哪些内存页表。就像房产证一样，证明这块内存是我的，别人不能乱动。

3.  **`ctx` (案发现场)**：
    *   这是最关键的部分！当厨师（CPU）要暂停做这道菜去处理别的事情时，他必须把当前的进度（寄存器值）记下来。
    *   `pc`：读到哪一行了。
    *   `sp`：锅里有什么。
    *   `r0-r12`：手头拿着什么调料。

## 3.3 调度：谁是下一个幸运儿？

EwokOS 的调度器 (Scheduler) 就像一个发号员。它的工作很简单：**决定下一个让谁用 CPU**。

EwokOS 使用的是**优先级调度**算法。
1.  **就绪队列**：所有准备好运行的进程都在这里排队。
2.  **Tick**：时钟每隔一段时间（比如 10ms）就会滴答一下，提醒调度器：“该换人了！”
3.  **挑选**：调度器看一眼队列，挑一个优先级最高的进程。
4.  **切换**：把当前进程踢下去，把新进程换上来。

## 3.4 上下文切换：魔术般的瞬间

**上下文切换 (Context Switch)** 是操作系统最迷人的魔术。
当 CPU 从进程 A 切换到进程 B 时，发生了什么？

1.  **冻结 A**：把 A 的所有寄存器值（案发现场）保存到 A 的 `proc_t->ctx` 里。
2.  **加载 B**：从 B 的 `proc_t->ctx` 里读出寄存器值，填回 CPU。
3.  **继续**：CPU 指针指向 B 上次停下的地方，继续执行。

对进程 A 来说，它感觉自己只是眨了一下眼（虽然可能过了几百毫秒），世界就变了。

## 3.5 线程：轻量级的进程

如果进程是“一道菜”，**线程 (Thread)** 就是“这道菜里的不同工序”。
*   洗菜、切菜、炒菜可以同时进行（如果有多核 CPU）。
*   它们共享同一个厨房（内存空间）。
*   它们共享同一份食材（全局变量）。

在 EwokOS 中，线程被视为“共享地址空间的进程”。它们有自己的 `ctx` 和栈，但共用 `space`。

下一章，我们将看看这些独立的进程是如何“打电话”沟通的。
