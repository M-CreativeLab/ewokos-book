
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <title>第三章：幕后黑手 - 进程与线程 · EwokOS Microkernel Booklet</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 4.0.8">
        <meta name="author" content="Misa.Z">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/honkit-plugin-mermaid/mermaid.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chapter4_ipc.html" />
    
    
    <link rel="prev" href="chapter2_arch.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    前言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="chapter1_intro.html">
            
                <a href="chapter1_intro.html">
            
                    
                    第一章：操作系统的世界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="chapter2_arch.html">
            
                <a href="chapter2_arch.html">
            
                    
                    第二章：EwokOS - 小内核，大梦想
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4" data-path="chapter3_proc.html">
            
                <a href="chapter3_proc.html">
            
                    
                    第三章：幕后黑手 - 进程与线程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="chapter4_ipc.html">
            
                <a href="chapter4_ipc.html">
            
                    
                    第四章：喂，听得见吗？ - IPC
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="chapter5_memory.html">
            
                <a href="chapter5_memory.html">
            
                    
                    第五章：包租公 - 内存管理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="chapter6_drivers.html">
            
                <a href="chapter6_drivers.html">
            
                    
                    第六章：打工魂 - 驱动与 VFS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="chapter7_hands_on.html">
            
                <a href="chapter7_hands_on.html">
            
                    
                    第七章：把手弄脏 - 编译与运行
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            本书使用 HonKit 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >第三章：幕后黑手 - 进程与线程</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="第三章：幕后黑手---进程与线程">第三章：幕后黑手 - 进程与线程</h1>
<p>在上一章中，我们从架构层面理解了 EwokOS 的整体设计。现在，让我们深入系统的&quot;心脏&quot;——进程管理。这是操作系统最核心、最迷人的部分。如果没有进程管理，再强大的硬件也只能像一个傻瓜一样，一次只做一件事。</p>
<h2 id="31-什么是进程？">3.1 什么是进程？</h2>
<p>如果 CPU 是一个做菜的厨师，<strong>进程 (Process)</strong> 就是一道正在做的菜。</p>
<ul>
<li><strong>代码</strong>：菜谱。</li>
<li><strong>数据</strong>：食材。</li>
<li><strong>堆栈</strong>：切菜板和锅。</li>
<li><strong>PC 指针</strong>：厨师读到了菜谱的哪一行。</li>
</ul>
<p>在 EwokOS 中，进程是资源分配的最小单位。每个进程都有自己独立的厨房（内存空间），互不干扰。</p>
<h3 id="进程的诞生：unix-的革命性创新">进程的诞生：Unix 的革命性创新</h3>
<p>进程的概念看似简单，但它的发明却是计算机历史上的一次重大突破。</p>
<p>在 Unix 诞生之前（1960 年代），大多数操作系统使用的是<strong>作业 (Job)</strong> 的概念。一个作业从开始到结束，独占整个计算机。想要同时运行多个程序？你需要等第一个跑完，或者买更多计算机。</p>
<h4 id="没有进程的世界：回到-1960-年代">没有进程的世界：回到 1960 年代</h4>
<p>让我们想象一下，如果现代计算机仍然使用作业（Job）而不是进程（Process），会是什么样子：</p>
<p><strong>作业 (Job) 的特点</strong>：</p>
<ul>
<li><strong>批处理模式</strong>：你提交一个作业（比如编译程序），然后去喝咖啡。等待几分钟或几小时后，回来取结果。</li>
<li><strong>独占式执行</strong>：作业运行时，整个计算机的所有资源（CPU、内存、I/O）都属于它。就像你包场了整个电影院，但只有你一个人在看。</li>
<li><strong>无交互性</strong>：作业提交后就不能修改或控制了。如果程序有 bug 进入死循环，你只能重启整台机器。</li>
<li><strong>低效率</strong>：如果作业在等待磁盘 I/O（可能需要几十毫秒），CPU 就会闲置，完全浪费。</li>
</ul>
<p><strong>进程 (Process) 的革命性改变</strong>：</p>
<ul>
<li><strong>并发执行</strong>：多个程序&quot;同时&quot;运行（通过时间片轮转）。你可以一边编译代码，一边听音乐，一边下载文件。</li>
<li><strong>虚拟化</strong>：每个进程都以为自己独占了整个计算机，但实际上它们共享硬件资源。</li>
<li><strong>交互性</strong>：你可以随时切换窗口、暂停程序、发送信号（如 Ctrl+C）。</li>
<li><strong>高效利用</strong>：当进程 A 在等待 I/O 时，CPU 可以切换去运行进程 B。资源利用率从 20% 提升到 80% 以上。</li>
</ul>
<p><strong>Jobs 和 Process 的核心区别</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Job（作业）</th>
<th>Process（进程）</th>
</tr>
</thead>
<tbody>
<tr>
<td>调度粒度</td>
<td>作业级别（整个程序）</td>
<td>时间片级别（毫秒级）</td>
</tr>
<tr>
<td>内存管理</td>
<td>物理内存直接分配</td>
<td>虚拟内存，隔离保护</td>
</tr>
<tr>
<td>交互性</td>
<td>无（批处理）</td>
<td>高（实时响应）</td>
</tr>
<tr>
<td>并发性</td>
<td>串行执行</td>
<td>并发/并行执行</td>
</tr>
<tr>
<td>状态管理</td>
<td>简单（运行/完成）</td>
<td>复杂（多种状态转换）</td>
</tr>
<tr>
<td>资源利用率</td>
<td>低（20-30%）</td>
<td>高（70-90%）</td>
</tr>
</tbody>
</table>
<p>1969 年，Ken Thompson 和 Dennis Ritchie 在开发 Unix 时，创造性地引入了<strong>进程抽象</strong>。他们的核心洞察是：<strong>让每个程序都以为自己独占了整个计算机，但实际上操作系统在幕后快速切换</strong>。这就像魔术师的手法——观众看到的是连续的动作，实际上是一系列快速的离散操作。</p>
<p>这个设计如此成功，以至于 50 多年后的今天，几乎所有操作系统（包括 Windows、Linux、macOS、iOS、Android）都沿用了这个抽象。EwokOS 也不例外。</p>
<h2 id="32-进程的档案袋：proct">3.2 进程的档案袋：<code>proc_t</code></h2>
<p>内核怎么管理这么多进程呢？它给每个进程都建了一个档案袋，叫做 <code>proc_t</code>。
你可以在 <code>kernel/kernel/include/kernel/proc.h</code> 里找到它的定义。</p>
<pre><code class="lang-c">typedef struct st_proc {
    procinfo_t        info;           // 1. 基本信息
    proc_space_t*     space;          // 2. 领地（内存空间）
    context_t         ctx;            // 3. 案发现场（上下文）
    int64_t           sleep_counter;  // 4. 睡眠时间
    // ... 其他字段
} proc_t;
</code></pre>
<p>让我们打开这个档案袋看看，并详细理解每个字段为什么存在、何时被使用：</p>
<h3 id="1-info-基本信息---进程的身份证">1. <strong><code>info</code> (基本信息)</strong> - 进程的身份证</h3>
<p>这是进程最基本的身份信息，内核通过这些字段来识别和管理进程。</p>
<ul>
<li><p><strong><code>PID</code> (Process ID - 进程标识符)</strong>：</p>
<ul>
<li><strong>用途</strong>：全局唯一的进程标识符，从 0 开始递增分配。</li>
<li><strong>使用场景</strong>：<ul>
<li>当你在 Shell 中执行 <code>kill 1234</code> 时，内核通过 PID 1234 找到对应的进程。</li>
<li>父进程通过 <code>fork()</code> 返回的 PID 来追踪子进程。</li>
<li>IPC 通信时，进程需要指定目标进程的 PID。</li>
</ul>
</li>
<li><strong>如果没有 PID</strong>：内核无法区分不同的进程。想象医院里所有病人都没有病历号，医生如何找到正确的病人？</li>
</ul>
</li>
<li><p><strong><code>State</code> (进程状态)</strong>：</p>
<ul>
<li><strong>用途</strong>：标识进程当前所处的生命周期阶段。</li>
<li><strong>可能的值</strong>：<ul>
<li><code>CREATED</code>：刚被创建，尚未初始化完成</li>
<li><code>READY</code>：已准备好，等待调度器分配 CPU</li>
<li><code>RUNNING</code>：正在某个 CPU 核心上执行</li>
<li><code>BLOCKED</code>：等待 I/O 操作完成（如读取磁盘）</li>
<li><code>WAITING</code>：等待某个事件（如等待子进程退出）</li>
<li><code>SLEEPING</code>：主动休眠（如调用了 <code>sleep(100)</code>）</li>
<li><code>ZOMBIE</code>：已执行完毕，但父进程尚未回收其资源</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li>调度器只选择 <code>READY</code> 状态的进程来运行。</li>
<li>当磁盘驱动完成读取后，会将进程从 <code>BLOCKED</code> 改为 <code>READY</code>。</li>
<li><code>ps</code> 命令显示进程列表时，就是读取这个状态字段。</li>
</ul>
</li>
<li><strong>如果没有 State</strong>：调度器可能会试图运行一个正在等待 I/O 的进程，导致系统空转浪费 CPU。</li>
</ul>
</li>
<li><p><strong><code>PPID</code> (Parent PID - 父进程 ID)</strong>：</p>
<ul>
<li><strong>用途</strong>：记录谁创建了这个进程。</li>
<li><strong>使用场景</strong>：<ul>
<li>当子进程退出时，内核需要通过 PPID 找到父进程，发送 <code>SIGCHLD</code> 信号。</li>
<li>构建进程树：<code>pstree</code> 命令就是通过 PPID 关系来构建的。</li>
<li>孤儿进程处理：如果父进程先退出，内核会将子进程的 PPID 改为 1（init 进程）。</li>
</ul>
</li>
<li><strong>如果没有 PPID</strong>：内核无法知道子进程退出时应该通知谁，也无法正确处理僵尸进程。</li>
</ul>
</li>
<li><p><strong><code>Priority</code> (优先级)</strong>：</p>
<ul>
<li><strong>用途</strong>：决定进程调度的优先顺序。数字越小，优先级越高。</li>
<li><strong>使用场景</strong>：<ul>
<li>系统关键服务（如网络守护进程）设置高优先级（如 5），确保及时响应。</li>
<li>后台任务（如日志归档）设置低优先级（如 20），避免影响用户体验。</li>
<li>实时任务（如音频播放）需要最高优先级，避免卡顿。</li>
</ul>
</li>
<li><strong>如果没有 Priority</strong>：所有进程平等对待，导致重要任务被延迟。想象急诊病人和普通挂号者排同一个队。</li>
</ul>
</li>
<li><p><strong><code>Core ID</code> (CPU 核心 ID)</strong>：</p>
<ul>
<li><strong>用途</strong>：在多核系统中，标识进程当前运行在（或上次运行在）哪个 CPU 核心上。</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>CPU 亲和性 (Affinity)</strong>：将进程绑定到特定核心，提高 CPU 缓存命中率。</li>
<li><strong>负载均衡</strong>：避免所有进程都挤在核心 0 上，而核心 1-3 闲置。</li>
<li><strong>中断路由</strong>：硬件中断可以被路由到进程所在的核心，减少核间通信。</li>
</ul>
</li>
<li><strong>如果没有 Core ID</strong>：调度器可能频繁地在不同核心间迁移进程，导致缓存失效，性能下降 30-50%。</li>
</ul>
</li>
</ul>
<h3 id="2-space-领地---进程的内存空间">2. <strong><code>space</code> (领地)</strong> - 进程的内存空间</h3>
<p>这是进程最重要的资源之一，定义了进程可以访问的内存范围。</p>
<ul>
<li><p><strong>页目录指针 (<code>page_dir_entry_t* vm</code>)</strong>：</p>
<ul>
<li><strong>用途</strong>：指向进程的页表，记录虚拟地址到物理地址的映射关系。</li>
<li><strong>使用场景</strong>：<ul>
<li>进程访问内存时，MMU（内存管理单元）通过这个页表进行地址转换。</li>
<li>上下文切换时，内核会切换 CPU 的页表寄存器（ARM 中的 TTBR0）指向新进程的页目录。</li>
<li>实现内存隔离：进程 A 无法访问进程 B 的内存，因为它们使用不同的页表。</li>
</ul>
</li>
<li><strong>如果没有页表</strong>：所有进程共享同一个地址空间，任何进程都可以读写其他进程的内存，完全没有安全性和稳定性。</li>
</ul>
</li>
<li><p><strong>堆 (<code>heap</code>) 和栈 (<code>stack</code>) 范围</strong>：</p>
<ul>
<li><strong>用途</strong>：记录堆和栈的起始地址和大小。</li>
<li><strong>使用场景</strong>：<ul>
<li>当进程调用 <code>malloc()</code> 时，内核需要知道堆的当前边界，决定是否需要扩展（通过 <code>brk()</code> 系统调用）。</li>
<li>当函数调用导致栈溢出时，内核检查栈指针是否超出栈范围，触发段错误 (Segmentation Fault)。</li>
<li>栈向下增长、堆向上增长，内核需要确保它们不会相撞。</li>
</ul>
</li>
<li><strong>如果没有这些范围记录</strong>：进程可以无限制地使用内存，导致内存耗尽；也无法检测栈溢出等常见错误。</li>
</ul>
</li>
<li><p><strong><code>COW</code> (Copy-On-Write) 标记</strong>：</p>
<ul>
<li><strong>用途</strong>：标识哪些内存页面是写时复制的共享页面。</li>
<li><strong>使用场景</strong>：<ul>
<li><code>fork()</code> 创建子进程时，父子进程共享相同的物理内存页面，并标记为 COW。</li>
<li>当任何一方尝试写入这些页面时，触发缺页异常，内核复制页面，实现真正的独立。</li>
<li>大大提高 <code>fork()</code> 的效率：如果没有 COW，创建一个 100MB 的进程副本需要复制 100MB 内存。</li>
</ul>
</li>
<li><strong>如果没有 COW</strong>：<code>fork()</code> 性能将降低 10-100 倍，导致进程创建极其缓慢。</li>
</ul>
</li>
</ul>
<h3 id="3-ctx-案发现场---cpu-上下文">3. <strong><code>ctx</code> (案发现场)</strong> - CPU 上下文</h3>
<p>这是进程最核心的状态信息，记录了 CPU 执行到哪一步。</p>
<ul>
<li><p><strong><code>pc</code> (Program Counter - 程序计数器)</strong>：</p>
<ul>
<li><strong>用途</strong>：指向下一条要执行的指令地址。</li>
<li><strong>使用场景</strong>：<ul>
<li>上下文切换时，内核保存当前 PC 值，下次恢复时从此处继续执行。</li>
<li>异常处理时，内核需要知道异常发生在哪条指令。</li>
<li>调试器设置断点时，会修改 PC 值或在 PC 指向的位置插入断点指令。</li>
</ul>
</li>
<li><strong>如果没有 PC</strong>：进程被切换后无法恢复，每次都要从头开始运行。就像读书时不做书签，每次打开都从第 1 页开始。</li>
</ul>
</li>
<li><p><strong><code>sp</code> (Stack Pointer - 栈指针)</strong>：</p>
<ul>
<li><strong>用途</strong>：指向当前栈顶的位置。</li>
<li><strong>使用场景</strong>：<ul>
<li>函数调用时，参数和返回地址压入栈，SP 向下移动。</li>
<li>函数返回时，SP 恢复到调用前的位置。</li>
<li>上下文切换时，必须保存 SP，否则栈数据会混乱。</li>
</ul>
</li>
<li><strong>如果没有 SP</strong>：函数调用将完全无法工作，程序无法执行任何复杂逻辑。</li>
</ul>
</li>
<li><p><strong><code>lr</code> (Link Register - 链接寄存器)</strong>：</p>
<ul>
<li><strong>用途</strong>：在 ARM 架构中，保存函数返回地址。</li>
<li><strong>使用场景</strong>：<ul>
<li>调用函数时，硬件自动将返回地址存入 LR。</li>
<li>函数返回时，直接跳转到 LR 指向的地址。</li>
<li>嵌套函数调用时，LR 被保存到栈中。</li>
</ul>
</li>
<li><strong>如果没有 LR</strong>：需要用额外的指令和内存访问来管理返回地址，性能降低 10-20%。</li>
</ul>
</li>
<li><p><strong><code>r0-r12</code> (通用寄存器)</strong>：</p>
<ul>
<li><strong>用途</strong>：保存运算数据、函数参数、局部变量等。</li>
<li><strong>使用场景</strong>：<ul>
<li>进程正在计算 <code>a + b * c</code>，中间结果存储在这些寄存器中。</li>
<li>如果此时发生中断或上下文切换，必须保存这些值，否则计算结果会丢失。</li>
</ul>
</li>
<li><strong>如果没有保存寄存器</strong>：进程恢复后会使用错误的数据，导致计算结果完全错误。</li>
</ul>
</li>
<li><p><strong><code>cpsr</code> (Current Program Status Register - 当前程序状态寄存器)</strong>：</p>
<ul>
<li><strong>用途</strong>：保存 CPU 的状态标志（如零标志、负标志、进位标志）和处理器模式。</li>
<li><strong>使用场景</strong>：<ul>
<li>条件分支指令（如 <code>beq</code>, <code>bne</code>）依赖于 CPSR 中的标志位。</li>
<li>异常处理时，需要保存和恢复 CPSR 以确保正确的处理器模式。</li>
</ul>
</li>
<li><strong>如果没有 CPSR</strong>：条件判断将失效，程序逻辑完全混乱。</li>
</ul>
</li>
</ul>
<h3 id="4-sleepcounter-睡眠计数器---定时器">4. <strong><code>sleep_counter</code> (睡眠计数器)</strong> - 定时器</h3>
<ul>
<li><strong>用途</strong>：实现进程的定时休眠功能。</li>
<li><strong>使用场景</strong>：<ul>
<li>进程调用 <code>sleep(5)</code> 时，内核将 <code>sleep_counter</code> 设置为 5000（假设时钟频率为 1000Hz）。</li>
<li>每次时钟中断（通常每 10ms 一次），内核遍历所有睡眠进程，将计数器减 10。</li>
<li>当计数器归零时，将进程状态从 <code>SLEEPING</code> 改为 <code>READY</code>，加入调度队列。</li>
</ul>
</li>
<li><strong>如果没有 sleep_counter</strong>：进程无法精确休眠，只能通过忙等待（busy-waiting）实现延迟，白白浪费 CPU 资源。一个简单的 <code>sleep(1)</code> 会让 CPU 使用率达到 100%。</li>
</ul>
<hr>
<p>这个 <code>proc_t</code> 结构体看似简单，但每个字段都是经过精心设计的。它们共同构成了操作系统管理进程的完整基础设施。如果缺少任何一个字段，都会导致严重的功能缺失或性能问题。</p>
<h2 id="321-进程状态转换图">3.2.1 进程状态转换图</h2>
<pre><code>       fork()
   NEW -------&gt; READY --------+
                  ^            |
                  |  schedule()|
              wakeup()         v
   WAIT/BLOCK &lt;--------- RUNNING -----&gt; ZOMBIE ----&gt; (销毁)
      ^                     |              ^
      |  sleep()/           |              |
      +-- ipc_call()        +-- exit() ----+
</code></pre><p>进程的生命周期就像一场精心编排的舞台剧，每个状态都有其特定的意义和转换条件。让我们详细剖析每个状态转换的时机和原因。</p>
<h3 id="状态详解">状态详解</h3>
<h4 id="new-→-ready（出生）"><strong>NEW → READY</strong>（出生）</h4>
<ul>
<li><strong>触发条件</strong>：父进程调用 <code>fork()</code> 或内核启动 init 进程时。</li>
<li><strong>发生了什么</strong>：<ol>
<li>内核分配一个新的 <code>proc_t</code> 结构。</li>
<li>复制父进程的地址空间（通过 COW 机制，不会立即复制物理内存）。</li>
<li>初始化进程的上下文（寄存器、栈指针等）。</li>
<li>分配 PID，将进程加入就绪队列。</li>
</ol>
</li>
<li><strong>实际例子</strong>：<ul>
<li>你在 Shell 中输入 <code>ls</code>，Shell 进程调用 <code>fork()</code> 创建一个子进程。</li>
<li>子进程立即进入 READY 状态，等待调度器分配 CPU。</li>
</ul>
</li>
</ul>
<h4 id="ready-→-running（被选中）"><strong>READY → RUNNING</strong>（被选中）</h4>
<ul>
<li><strong>触发条件</strong>：调度器 <code>schedule()</code> 选中该进程。</li>
<li><strong>发生了什么</strong>：<ol>
<li>调度器从就绪队列中选择优先级最高的进程。</li>
<li>执行上下文切换（Context Switch）：<ul>
<li>保存当前进程的 CPU 寄存器到其 <code>proc_t-&gt;ctx</code>。</li>
<li>加载新进程的 <code>proc_t-&gt;ctx</code> 到 CPU 寄存器。</li>
<li>切换页表（修改 MMU 的页表基址寄存器）。</li>
</ul>
</li>
<li>CPU 开始执行新进程的代码。</li>
</ol>
</li>
<li><strong>实际例子</strong>：<ul>
<li>时钟中断（通常每 10ms）触发调度器运行。</li>
<li>调度器发现 <code>ls</code> 进程优先级高且处于 READY 状态，将其切换为 RUNNING。</li>
</ul>
</li>
</ul>
<h4 id="running-→-ready（被抢占）"><strong>RUNNING → READY</strong>（被抢占）</h4>
<ul>
<li><strong>触发条件</strong>：时间片用完，或更高优先级的进程就绪。</li>
<li><strong>发生了什么</strong>：<ol>
<li>时钟中断或其他中断发生。</li>
<li>内核调用 <code>schedule()</code>，发现当前进程时间片已用完。</li>
<li>将当前进程状态改为 READY，重新加入就绪队列。</li>
<li>选择下一个进程切换执行。</li>
</ol>
</li>
<li><strong>实际例子</strong>：<ul>
<li><code>ls</code> 进程运行了 10ms（一个时间片），但还没执行完。</li>
<li>时钟中断发生，调度器将 <code>ls</code> 改为 READY，切换到另一个进程（如 <code>vim</code>）。</li>
<li>几毫秒后，<code>ls</code> 再次被调度，继续执行。</li>
</ul>
</li>
</ul>
<h4 id="running-→-blockedwaiting（主动等待）"><strong>RUNNING → BLOCKED/WAITING</strong>（主动等待）</h4>
<ul>
<li><strong>触发条件</strong>：进程需要等待某个事件（I/O、IPC、子进程退出等）。</li>
<li><strong>发生了什么</strong>：<ol>
<li>进程执行系统调用，如：<ul>
<li><code>read(fd, buf, size)</code> - 等待磁盘数据</li>
<li><code>wait(&amp;status)</code> - 等待子进程退出</li>
<li><code>ipc_call()</code> - 等待 IPC 响应</li>
</ul>
</li>
<li>内核将进程状态改为 BLOCKED 或 WAITING。</li>
<li>将进程从就绪队列移除，放入等待队列。</li>
<li>立即调用 <code>schedule()</code> 切换到其他进程。</li>
</ol>
</li>
<li><strong>实际例子</strong>：<ul>
<li><code>cat big_file.txt</code> 进程调用 <code>read()</code> 读取磁盘文件。</li>
<li>磁盘读取需要几毫秒，进程进入 BLOCKED 状态。</li>
<li>CPU 不会空等，而是切换去运行其他进程。</li>
</ul>
</li>
</ul>
<h4 id="blockedwaiting-→-ready（被唤醒）"><strong>BLOCKED/WAITING → READY</strong>（被唤醒）</h4>
<ul>
<li><strong>触发条件</strong>：等待的事件完成（I/O 完成、IPC 响应、子进程退出等）。</li>
<li><strong>发生了什么</strong>：<ol>
<li>事件发生（如磁盘驱动完成数据传输）。</li>
<li>中断处理程序或其他进程调用 <code>wakeup(pid)</code>。</li>
<li>内核将进程状态从 BLOCKED 改为 READY。</li>
<li>将进程重新加入就绪队列，等待调度。</li>
</ol>
</li>
<li><strong>实际例子</strong>：<ul>
<li>磁盘驱动完成了 <code>cat</code> 进程的读取请求。</li>
<li>驱动程序调用 <code>wakeup(cat_pid)</code>。</li>
<li><code>cat</code> 进程状态变为 READY，等待下次被调度。</li>
</ul>
</li>
</ul>
<h4 id="running-→-sleeping（定时休眠）"><strong>RUNNING → SLEEPING</strong>（定时休眠）</h4>
<ul>
<li><strong>触发条件</strong>：进程调用 <code>sleep(n)</code> 或 <code>usleep(n)</code>。</li>
<li><strong>发生了什么</strong>：<ol>
<li>进程执行 <code>sleep(5)</code> 系统调用。</li>
<li>内核将进程的 <code>sleep_counter</code> 设置为 5000（假设时钟频率 1000Hz）。</li>
<li>将进程状态改为 SLEEPING，从就绪队列移除。</li>
<li>每次时钟中断，内核递减 <code>sleep_counter</code>。</li>
<li>当计数器归零时，自动触发 SLEEPING → READY 转换。</li>
</ol>
</li>
<li><strong>实际例子</strong>：<ul>
<li>一个守护进程每 5 秒检查一次邮件：<code>while(1) { check_mail(); sleep(5); }</code></li>
<li>调用 <code>sleep(5)</code> 后，进程让出 CPU，不浪费资源。</li>
</ul>
</li>
</ul>
<h4 id="running-→-zombie（进程已死，灵魂未散）"><strong>RUNNING → ZOMBIE</strong>（进程已死，灵魂未散）</h4>
<ul>
<li><strong>触发条件</strong>：进程执行完毕（<code>main</code> 返回或调用 <code>exit()</code>），但父进程尚未回收。</li>
<li><strong>发生了什么</strong>：<ol>
<li>进程执行 <code>exit(0)</code> 或 <code>main</code> 函数返回。</li>
<li>内核释放进程的大部分资源（内存、文件描述符等）。</li>
<li>但保留 <code>proc_t</code> 结构（包含退出状态码）。</li>
<li>将进程状态改为 ZOMBIE。</li>
<li>向父进程发送 <code>SIGCHLD</code> 信号。</li>
</ol>
</li>
<li><strong>为什么需要 ZOMBIE 状态</strong>？<ul>
<li>父进程需要通过 <code>wait()</code> 获取子进程的退出状态码。</li>
<li>如果立即销毁 <code>proc_t</code>，父进程就无法知道子进程是成功（返回 0）还是失败（返回非 0）。</li>
<li>ZOMBIE 就像墓碑，记录着进程的&quot;遗言&quot;（退出状态）。</li>
</ul>
</li>
<li><strong>实际例子</strong>：<ul>
<li>Shell 执行 <code>ls</code> 命令，<code>fork()</code> 创建子进程。</li>
<li><code>ls</code> 子进程执行完毕，调用 <code>exit(0)</code>。</li>
<li><code>ls</code> 进入 ZOMBIE 状态，等待 Shell 调用 <code>wait()</code> 回收。</li>
<li>Shell 调用 <code>wait(&amp;status)</code> 后，获取退出状态，<code>ls</code> 的 <code>proc_t</code> 才被完全销毁。</li>
</ul>
</li>
<li><strong>僵尸进程的危害</strong>：<ul>
<li>如果父进程忘记调用 <code>wait()</code>，ZOMBIE 进程会一直存在。</li>
<li>每个 ZOMBIE 占用一个 PID 和一个 <code>proc_t</code> 结构（几百字节）。</li>
<li>如果大量僵尸进程积累，可能耗尽 PID 空间（通常上限是 32768）。</li>
</ul>
</li>
</ul>
<h4 id="zombie-→-销毁（魂飞魄散）"><strong>ZOMBIE → 销毁</strong>（魂飞魄散）</h4>
<ul>
<li><strong>触发条件</strong>：父进程调用 <code>wait()</code> 或 <code>waitpid()</code>。</li>
<li><strong>发生了什么</strong>：<ol>
<li>父进程调用 <code>wait(&amp;status)</code> 阻塞等待子进程退出。</li>
<li>内核找到 ZOMBIE 状态的子进程。</li>
<li>将退出状态码复制给父进程的 <code>status</code> 变量。</li>
<li>完全销毁子进程的 <code>proc_t</code> 结构。</li>
<li>回收 PID，供后续进程使用。</li>
</ol>
</li>
<li><strong>实际例子</strong>：<ul>
<li>Shell 执行完 <code>ls</code> 命令后，立即调用 <code>wait()</code> 回收子进程。</li>
<li>这就是为什么 Shell 命令执行后，不会留下僵尸进程。</li>
</ul>
</li>
</ul>
<h3 id="特殊情况：孤儿进程">特殊情况：孤儿进程</h3>
<ul>
<li><strong>什么是孤儿进程</strong>？父进程先于子进程退出，子进程成为孤儿。</li>
<li><strong>系统如何处理</strong>？<ol>
<li>内核检测到父进程退出时，会将其所有子进程的 PPID 改为 1（init 进程）。</li>
<li>init 进程会定期调用 <code>wait()</code> 回收所有孤儿进程。</li>
<li>这确保了系统中不会有永久的僵尸进程。</li>
</ol>
</li>
</ul>
<h3 id="状态转换的性能影响">状态转换的性能影响</h3>
<ul>
<li><p><strong>频繁的 READY ↔ RUNNING 切换</strong>（上下文切换）：</p>
<ul>
<li>每次切换需要保存/加载寄存器、切换页表、刷新 TLB（Translation Lookaside Buffer）。</li>
<li>单次切换开销约 1-10 微秒，但如果每秒切换上千次，累积开销可达 10-20% CPU 时间。</li>
</ul>
</li>
<li><p><strong>RUNNING → BLOCKED 转换的优势</strong>：</p>
<ul>
<li>避免了 CPU 空转等待 I/O。</li>
<li>如果没有这个状态，进程只能忙等待（busy-waiting），浪费 CPU 资源。</li>
</ul>
</li>
<li><p><strong>ZOMBIE 状态的必要性</strong>：</p>
<ul>
<li>虽然占用少量内存，但提供了父子进程间的同步机制。</li>
<li>如果没有 ZOMBIE，父进程无法获知子进程的退出状态，很多程序逻辑会失效。</li>
</ul>
</li>
</ul>
<p>理解这些状态转换，是掌握操作系统进程管理的关键。每个状态都不是凭空设计的，而是为了解决实际问题而引入的。</p>
<h2 id="33-调度：谁是下一个幸运儿？">3.3 调度：谁是下一个幸运儿？</h2>
<p>想象一下你在医院急诊室。有人只是擦伤了膝盖，有人心脏病突发，有人骨折，还有人只是来体检。如果按先来先服务的原则，心脏病患者可能要等体检的人做完检查才能得到救治——这显然是荒谬的。</p>
<p><strong>调度器 (Scheduler)</strong> 就是操作系统的&quot;急诊分诊护士&quot;，它的职责是：<strong>在众多等待 CPU 的进程中，决定下一个谁应该获得 CPU 资源</strong>。</p>
<h3 id="为什么需要调度器？">为什么需要调度器？</h3>
<p>如果没有调度器会怎样？让我们看一个具体场景：</p>
<p><strong>场景：你的电脑同时运行三个程序</strong></p>
<ol>
<li><strong>浏览器</strong>：正在播放在线视频（需要每 16ms 解码一帧，否则会卡顿）</li>
<li><strong>编译器</strong>：正在编译一个大型项目（需要 CPU 密集计算 10 秒）</li>
<li><strong>备份程序</strong>：正在后台备份文件（I/O 密集，经常等待磁盘）</li>
</ol>
<p><strong>没有调度器的世界</strong>：</p>
<ul>
<li>浏览器先抢到 CPU，播放 1 秒视频后，编译器才能运行。</li>
<li>编译器开始运行，持续占用 CPU 10 秒，浏览器视频完全卡死。</li>
<li>用户体验极差，系统看起来&quot;死机&quot;了。</li>
</ul>
<p><strong>有调度器的世界</strong>：</p>
<ul>
<li>调度器每 10ms 轮换一次：浏览器 → 编译器 → 备份 → 浏览器 → ...</li>
<li>浏览器获得足够频繁的 CPU 时间，视频流畅播放。</li>
<li>编译器虽然被频繁打断，但总体上仍在推进。</li>
<li>备份程序在等待磁盘 I/O 时，CPU 被分配给其他进程，没有浪费。</li>
</ul>
<p>调度器的核心作用就是：<strong>在保证系统响应性的同时，最大化 CPU 利用率</strong>。</p>
<h3 id="调度器具体调度什么？">调度器具体调度什么？</h3>
<p>调度器管理的是 <strong>CPU 时间</strong> 这一稀缺资源。具体来说：</p>
<ol>
<li><strong>时间片分配</strong>：将 CPU 时间切成小块（通常 10ms），分配给不同进程。</li>
<li><strong>优先级管理</strong>：重要的进程（如 GUI、音频播放）获得更多、更频繁的时间片。</li>
<li><strong>资源均衡</strong>：避免某些进程饿死（永远得不到 CPU）。</li>
<li><strong>核心分配</strong>（多核系统）：决定进程运行在哪个 CPU 核心上。</li>
</ol>
<h3 id="ewokos-的调度实现">EwokOS 的调度实现</h3>
<p>EwokOS 使用的是<strong>优先级调度 (Priority Scheduling)</strong> 算法。其工作流程如下：</p>
<ol>
<li><strong>就绪队列 (Ready Queue)</strong>：所有处于 READY 状态的进程都在这里排队，按优先级排序。</li>
<li><strong>时钟滴答 (Tick)</strong>：硬件时钟每隔一段时间（如 10ms）触发一次中断。</li>
<li><strong>调度决策</strong>：中断处理程序调用调度器，从就绪队列选择优先级最高的进程。</li>
<li><strong>上下文切换 (Context Switch)</strong>：保存当前进程状态，加载新进程状态，切换执行。</li>
</ol>
<p><strong>关键代码片段</strong> (<code>kernel/kernel/src/sched.c</code>)：</p>
<pre><code class="lang-c">void schedule(context_t* ctx) {
    // 1. 保存当前进程的上下文
    if(_current_proc != NULL)
        proc_save(ctx);

    // 2. 从就绪队列选择下一个进程
    _current_proc = proc_get_next_ready();

    // 3. 如果没有就绪进程，运行空闲进程
    if(_current_proc == NULL)
        _current_proc = _idle_proc;

    // 4. 加载新进程的上下文
    proc_load(ctx);
}
</code></pre>
<p><strong>空闲进程 (Idle Process)</strong>：</p>
<ul>
<li>当所有进程都在等待 I/O 时，CPU 运行 idle 进程。</li>
<li>Idle 进程的任务很简单：执行低功耗指令（如 ARM 的 <code>WFI</code> - Wait For Interrupt）。</li>
<li>这可以节省电量，延长电池寿命（对嵌入式设备很重要）。</li>
</ul>
<h3 id="调度算法的演变：从简单到复杂">调度算法的演变：从简单到复杂</h3>
<p>操作系统调度算法经历了几十年的演化，让我们来看这段有趣的历史：</p>
<h4 id="1-先来先服务-fcfs-first-come-first-served---1950年代"><strong>1. 先来先服务 (FCFS, First-Come-First-Served)</strong> - 1950年代</h4>
<ul>
<li><strong>原理</strong>：谁先到谁先执行，直到执行完毕或主动放弃 CPU。</li>
<li><strong>优点</strong>：实现简单，公平（按到达顺序）。</li>
<li><strong>缺点</strong>：<ul>
<li><strong>护航效应 (Convoy Effect)</strong>：一个长作业会阻塞后面所有短作业。</li>
<li>平均等待时间长，用户体验差。</li>
</ul>
</li>
<li><strong>实际例子</strong>：<ul>
<li>进程 A 需要运行 1 小时（编译内核）。</li>
<li>进程 B 只需要 1 秒（打开记事本）。</li>
<li>如果 A 先到达，B 要等 1 小时。用户会认为系统&quot;死机&quot;了。</li>
</ul>
</li>
</ul>
<h4 id="2-时间片轮转-round-robin-rr---1960年代"><strong>2. 时间片轮转 (Round Robin, RR)</strong> - 1960年代</h4>
<ul>
<li><strong>原理</strong>：每个进程分配固定时间片（如 10ms），时间到了就轮换到下一个。</li>
<li><strong>历史意义</strong>：这是 <strong>分时系统 (Time-Sharing)</strong> 的核心算法，由麻省理工学院在 1960 年代发明。</li>
<li><strong>优点</strong>：<ul>
<li>所有进程都能获得响应，避免长时间等待。</li>
<li>实现简单，容易理解。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>所有进程平等对待，无法区分优先级。</li>
<li>时间片太短导致频繁切换（开销大），太长导致响应慢。</li>
</ul>
</li>
<li><strong>实际例子</strong>：<ul>
<li>Unix 早期版本（1970 年代）使用这个算法。</li>
<li>时间片通常设为 100ms，兼顾响应性和效率。</li>
</ul>
</li>
</ul>
<h4 id="3-优先级调度-priority-scheduling---1970年代"><strong>3. 优先级调度 (Priority Scheduling)</strong> - 1970年代</h4>
<ul>
<li><strong>原理</strong>：每个进程有优先级（数字越小越高），高优先级优先执行。</li>
<li><strong>EwokOS 使用这个算法</strong>：简单高效，适合嵌入式系统。</li>
<li><strong>优点</strong>：<ul>
<li>可以保证重要进程（如实时任务）优先执行。</li>
<li>灵活性高，可以根据需求调整优先级。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>饿死 (Starvation)</strong>：低优先级进程可能永远得不到执行。</li>
<li>需要合理设计优先级，避免系统失衡。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>优先级老化 (Aging)</strong>：进程等待时间越长，优先级逐渐提升。</li>
<li>防止低优先级进程饿死。</li>
</ul>
</li>
<li><strong>实际例子</strong>：<ul>
<li>音频播放器优先级设为 5（高）：确保不卡顿。</li>
<li>后台备份优先级设为 20（低）：不影响前台任务。</li>
<li>普通应用优先级设为 10（中）：平衡性能。</li>
</ul>
</li>
</ul>
<h4 id="4-多级反馈队列-multi-level-feedback-queue-mlfq---1980年代"><strong>4. 多级反馈队列 (Multi-Level Feedback Queue, MLFQ)</strong> - 1980年代</h4>
<ul>
<li><strong>原理</strong>：维护多个优先级队列，进程根据行为动态调整优先级。</li>
<li><strong>行为</strong>：<ul>
<li>新进程从最高优先级队列开始。</li>
<li>如果进程用完时间片，降级到下一个队列。</li>
<li>如果进程频繁 I/O（交互式），保持高优先级。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>自动识别 I/O 密集型（交互式）和 CPU 密集型进程。</li>
<li>无需手动设置优先级。</li>
</ul>
</li>
<li><strong>实际例子</strong>：<ul>
<li>Windows NT（1993 年）和 macOS 使用这个算法。</li>
</ul>
</li>
</ul>
<h4 id="5-完全公平调度器-cfs-completely-fair-scheduler---2007年"><strong>5. 完全公平调度器 (CFS, Completely Fair Scheduler)</strong> - 2007年</h4>
<ul>
<li><strong>原理</strong>：Linux 2.6.23 引入，使用红黑树跟踪每个进程的&quot;虚拟运行时间&quot;。</li>
<li><strong>核心思想</strong>：<ul>
<li>每个进程都应该获得 <code>1/N</code> 的 CPU 时间（N 是进程数）。</li>
<li>跟踪每个进程的 <code>vruntime</code>（虚拟运行时间）。</li>
<li>总是选择 <code>vruntime</code> 最小的进程运行，确保公平。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>极其公平，避免饿死。</li>
<li>自动适应不同负载。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>实现复杂，需要红黑树数据结构。</li>
<li>不适合硬实时系统（无法保证响应时间上限）。</li>
</ul>
</li>
<li><strong>实际例子</strong>：<ul>
<li>Linux 桌面和服务器系统的标准调度器。</li>
<li>Android 系统也使用 CFS。</li>
</ul>
</li>
</ul>
<p><strong>EwokOS 为什么选择优先级调度？</strong></p>
<ul>
<li><strong>简单性</strong>：代码量少，易于理解和调试。</li>
<li><strong>可预测性</strong>：高优先级进程总是优先执行，适合实时应用。</li>
<li><strong>效率</strong>：选择下一个进程的时间复杂度 O(1)，而 CFS 是 O(log N)。</li>
<li><strong>适用性</strong>：嵌入式系统和微内核架构更重视确定性，而不是绝对公平。</li>
</ul>
<h3 id="多核调度-smp-scheduling：让多个厨师协同工作">多核调度 (SMP Scheduling)：让多个厨师协同工作</h3>
<p>在单核时代，调度器的任务相对简单：管理一个 CPU 和一个就绪队列。但现代 CPU 通常有 2、4、8 甚至更多核心。<strong>多核 (Multi-Core)</strong> 是指一个 CPU 芯片上集成了多个独立的处理核心，每个核心都可以同时执行不同的进程。</p>
<p>举个例子：</p>
<ul>
<li><strong>单核 CPU</strong>：就像一个厨师，必须按顺序做菜——炒完菜 A 才能炒菜 B。</li>
<li><strong>4 核 CPU</strong>：就像 4 个厨师，可以同时炒 4 道菜，效率提升 4 倍（理想情况）。</li>
<li><strong>超线程 (Hyper-Threading)</strong>：一个物理核心模拟成 2 个逻辑核心，利用 CPU 的空闲执行单元。</li>
</ul>
<h4 id="多核调度的挑战">多核调度的挑战</h4>
<p><strong>挑战 1：负载均衡</strong></p>
<ul>
<li><strong>问题</strong>：如何避免某些核心忙碌，而其他核心空闲？</li>
<li><strong>例子</strong>：<ul>
<li>4 个进程全部运行在核心 0 上，而核心 1-3 空闲。</li>
<li>导致系统性能只发挥了 25%。</li>
</ul>
</li>
<li><strong>后果</strong>：CPU 利用率低，用户体验差（部分核心过载，部分核心空闲）。</li>
</ul>
<p><strong>挑战 2：缓存一致性</strong></p>
<ul>
<li><strong>问题</strong>：进程在不同核心间迁移会导致缓存失效。</li>
<li><strong>背景</strong>：每个 CPU 核心都有独立的 L1/L2 缓存（几百 KB），用于加速内存访问。</li>
<li><strong>例子</strong>：<ul>
<li>进程 A 在核心 0 上运行，L1 缓存已经加载了代码和数据。</li>
<li>调度器将 A 迁移到核心 1，核心 1 的 L1 缓存是空的。</li>
<li>需要重新从内存加载数据，性能损失 30-50%。</li>
</ul>
</li>
<li><strong>解决方案</strong>：尽量让进程在同一核心运行（CPU 亲和性）。</li>
</ul>
<p><strong>挑战 3：同步和锁竞争</strong></p>
<ul>
<li><strong>问题</strong>：多个核心可能同时访问调度器数据结构（就绪队列）。</li>
<li><strong>例子</strong>：<ul>
<li>核心 0 和核心 1 同时调用 <code>schedule()</code>。</li>
<li>如果没有锁保护，可能两个核心选择同一个进程，导致数据错误。</li>
</ul>
</li>
<li><strong>解决方案</strong>：使用自旋锁 (Spinlock) 保护临界区。</li>
</ul>
<h4 id="ewokos-的多核调度策略">EwokOS 的多核调度策略</h4>
<p><strong>1. 每核心就绪队列 (Per-Core Ready Queue)</strong></p>
<ul>
<li>每个 CPU 核心维护自己独立的就绪队列。</li>
<li><strong>优点</strong>：<ul>
<li>减少锁竞争：核心通常只访问自己的队列。</li>
<li>提高缓存命中率：进程倾向于在同一核心运行。</li>
</ul>
</li>
<li><p><strong>实现</strong>：</p>
<pre><code class="lang-c">struct cpu_core {
    proc_t* ready_queue;      // 就绪队列
    proc_t* current_proc;     // 当前运行进程
    spinlock_t queue_lock;    // 队列锁
};

cpu_core cores[MAX_CPUS];
</code></pre>
</li>
</ul>
<p><strong>2. 负载均衡 (Load Balancing)</strong></p>
<ul>
<li><strong>被动均衡 - 工作窃取 (Work Stealing)</strong>：<ul>
<li>空闲核心主动&quot;偷&quot;其他核心的进程。</li>
<li>实现简单，开销低。</li>
</ul>
</li>
<li><strong>主动均衡 - 定期迁移</strong>：<ul>
<li>定期（如每 100ms）检查各核心负载。</li>
<li>强制将任务从忙碌核心迁移到空闲核心。</li>
</ul>
</li>
<li><strong>实现示例</strong>：<pre><code class="lang-c">// 核心 1 空闲时，尝试从其他核心偷进程
if (cores[1].ready_queue == NULL) {
    for (int i = 0; i &lt; MAX_CPUS; i++) {
        if (i != 1 &amp;&amp; cores[i].ready_queue != NULL) {
            proc_t* stolen = steal_process(&amp;cores[i]);
            if (stolen != NULL) {
                add_to_queue(&amp;cores[1], stolen);
                break;
            }
        }
    }
}
</code></pre>
</li>
</ul>
<p><strong>3. CPU 亲和性 (CPU Affinity)</strong></p>
<ul>
<li><strong>概念</strong>：允许进程绑定到特定核心或核心集合。</li>
<li><strong>优点</strong>：<ul>
<li>提高缓存命中率（进程总是在同一核心运行）。</li>
<li>避免频繁迁移的开销。</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>实时任务</strong>：绑定到特定核心，避免被其他进程干扰。</li>
<li><strong>NUMA 系统</strong>：将进程绑定到内存最近的核心，减少访问延迟。</li>
<li><strong>性能关键应用</strong>：如数据库服务器、游戏服务器。</li>
</ul>
</li>
<li><strong>实现</strong>：<pre><code class="lang-c">// 设置进程只能在核心 0 和 1 上运行
proc_set_affinity(pid, CPU_MASK(0) | CPU_MASK(1));
</code></pre>
</li>
</ul>
<p><strong>4. 临界区保护：自旋锁 (Spinlock)</strong></p>
<ul>
<li><strong>为什么需要锁</strong>：多个核心可能同时访问共享数据结构。</li>
<li><strong>自旋锁原理</strong>：<ul>
<li>如果锁已被占用，核心会&quot;自旋&quot;（循环等待），而不是睡眠。</li>
<li>适用于持锁时间很短的场景（如几微秒）。</li>
</ul>
</li>
<li><strong>实现</strong>：<pre><code class="lang-c">void schedule_on_core(int core_id) {
    spinlock_lock(&amp;cores[core_id].queue_lock);
    // 访问就绪队列
    proc_t* next = get_next_ready(&amp;cores[core_id]);
    spinlock_unlock(&amp;cores[core_id].queue_lock);
    // 切换到新进程
    context_switch(next);
}
</code></pre>
</li>
<li><strong>为什么不用睡眠锁（Mutex）</strong>：<ul>
<li>睡眠锁需要调度器，但调度器本身就需要锁，会产生循环依赖。</li>
<li>自旋锁的持锁时间极短（几微秒），自旋开销小于睡眠唤醒开销。</li>
</ul>
</li>
</ul>
<p><strong>5. 核间中断 (IPI, Inter-Processor Interrupt)</strong></p>
<ul>
<li><strong>概念</strong>：一个核心可以向其他核心发送中断，通知它们执行特定操作。</li>
<li><strong>应用场景</strong>：<ul>
<li><strong>唤醒空闲核心</strong>：进程被唤醒后，通知目标核心重新调度。</li>
<li><strong>TLB 刷新</strong>：修改页表后，通知其他核心刷新 TLB（Translation Lookaside Buffer）。</li>
<li><strong>停止核心</strong>：系统关机时，通知所有核心停止执行。</li>
</ul>
</li>
<li><p><strong>实现</strong>：</p>
<pre><code class="lang-c">// 核心 0 通知核心 1 重新调度
send_ipi(1, IPI_RESCHEDULE);

// 核心 1 收到 IPI 中断
void ipi_handler() {
    if (ipi_type == IPI_RESCHEDULE) {
        schedule(get_context());
    }
}
</code></pre>
</li>
</ul>
<h4 id="多核调度的实际例子">多核调度的实际例子</h4>
<p><strong>场景</strong>：4 核 CPU，运行 8 个进程（A-H）</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>核心 0</th>
<th>核心 1</th>
<th>核心 2</th>
<th>核心 3</th>
</tr>
</thead>
<tbody>
<tr>
<td>T0</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
</tr>
<tr>
<td>T1</td>
<td>E</td>
<td>F</td>
<td>G</td>
<td>H</td>
</tr>
<tr>
<td>T2</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>(空闲)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>T0</strong>：所有核心都在运行进程。</li>
<li><strong>T1</strong>：调度器切换，每个核心运行新进程。</li>
<li><strong>T2</strong>：进程 D 和 H 退出，核心 3 变为空闲。</li>
<li><strong>负载均衡</strong>：<ul>
<li>核心 3 检测到自己空闲。</li>
<li>尝试从其他核心&quot;偷&quot;进程：发现核心 0 的就绪队列中有进程 E 等待。</li>
<li>将 E 迁移到核心 3 运行。</li>
</ul>
</li>
</ul>
<p>这就是多核调度的魅力：让多个 CPU 核心高效协作，最大化系统吞吐量和响应性。</p>
<h2 id="34-上下文切换：魔术般的瞬间">3.4 上下文切换：魔术般的瞬间</h2>
<p><strong>上下文切换 (Context Switch)</strong> 是操作系统最迷人的魔术。想象一下：你正在看一本侦探小说，看到关键情节时电话响了。你接完电话回来，能够毫无障碍地继续阅读——这就是因为你的大脑记住了&quot;上下文&quot;（读到哪一页、主角是谁、案件进展如何）。</p>
<p>操作系统的上下文切换就是这样的魔术：让 CPU 可以在多个进程之间快速切换，而每个进程都感觉不到自己被打断过。</p>
<h3 id="为什么需要上下文切换？">为什么需要上下文切换？</h3>
<p><strong>场景 1：充分利用 CPU</strong></p>
<ul>
<li>进程 A 正在等待磁盘读取（需要 5ms）。</li>
<li>如果 CPU 傻等着，这 5ms 就浪费了。</li>
<li>通过上下文切换，CPU 可以在这 5ms 内运行进程 B，提高利用率。</li>
</ul>
<p><strong>场景 2：实现多任务</strong></p>
<ul>
<li>用户同时运行浏览器、音乐播放器、编辑器。</li>
<li>单核 CPU 通过快速切换（如每 10ms 一次），让用户感觉三个程序&quot;同时&quot;运行。</li>
</ul>
<p><strong>场景 3：响应紧急任务</strong></p>
<ul>
<li>系统正在运行后台备份（低优先级）。</li>
<li>用户点击鼠标（高优先级）。</li>
<li>通过上下文切换，立即暂停备份，响应鼠标点击，保证系统交互性。</li>
</ul>
<p><strong>如果没有上下文切换</strong>：</p>
<ul>
<li>系统只能串行执行进程，一个进程运行完才能运行下一个。</li>
<li>I/O 等待时 CPU 空闲，利用率从 80% 降到 20%。</li>
<li>用户体验极差，感觉系统&quot;卡顿&quot;。</li>
</ul>
<h3 id="上下文切换的详细过程">上下文切换的详细过程</h3>
<p>当 CPU 从进程 A 切换到进程 B 时，发生了什么？</p>
<h4 id="第-1-步：触发切换"><strong>第 1 步：触发切换</strong></h4>
<p>上下文切换可以由多种事件触发：</p>
<ul>
<li><strong>时钟中断</strong>：时间片用完（如 10ms）。</li>
<li><strong>系统调用</strong>：进程调用 <code>sleep()</code>、<code>read()</code>、<code>wait()</code> 等，主动让出 CPU。</li>
<li><strong>中断</strong>：硬件中断（如磁盘 I/O 完成），唤醒等待的进程。</li>
<li><strong>抢占</strong>：高优先级进程就绪，抢占当前进程。</li>
</ul>
<h4 id="第-2-步：保存现场（进程-a-的上下文）"><strong>第 2 步：保存现场（进程 A 的上下文）</strong></h4>
<p>内核必须保存进程 A 的所有 CPU 状态，确保下次恢复时能继续执行。</p>
<pre><code class="lang-c">void proc_save(context_t* ctx) {
    if (_current_proc == NULL)
        return;

    // 保存 CPU 寄存器到进程的 ctx 结构
    memcpy(&amp;_current_proc-&gt;ctx, ctx, sizeof(context_t));

    // ctx 包含：
    // - pc (Program Counter)：下一条要执行的指令
    // - sp (Stack Pointer)：栈顶位置
    // - r0-r12：通用寄存器
    // - cpsr：状态寄存器
    // - lr (Link Register)：返回地址
}
</code></pre>
<p><strong>需要保存的内容</strong>：</p>
<ol>
<li><strong>程序计数器 (PC)</strong>：记录进程执行到哪一条指令。</li>
<li><strong>栈指针 (SP)</strong>：记录栈顶位置，函数调用依赖它。</li>
<li><strong>通用寄存器 (r0-r12)</strong>：保存进程的计算数据。</li>
<li><strong>状态寄存器 (CPSR)</strong>：保存条件标志位（零标志、负标志等）。</li>
<li><strong>链接寄存器 (LR)</strong>：保存函数返回地址。</li>
</ol>
<h4 id="第-3-步：选择下一个进程"><strong>第 3 步：选择下一个进程</strong></h4>
<p>调度器从就绪队列中选择下一个要运行的进程：</p>
<pre><code class="lang-c">proc_t* proc_get_next_ready() {
    // 遍历所有进程，找到优先级最高的 READY 进程
    proc_t* best = NULL;
    int best_priority = INT_MAX;

    for (int i = 0; i &lt; MAX_PROCS; i++) {
        proc_t* p = &amp;procs[i];
        if (p-&gt;info.state == READY &amp;&amp; p-&gt;info.priority &lt; best_priority) {
            best = p;
            best_priority = p-&gt;info.priority;
        }
    }

    return best;
}
</code></pre>
<h4 id="第-4-步：恢复现场（进程-b-的上下文）"><strong>第 4 步：恢复现场（进程 B 的上下文）</strong></h4>
<p>将进程 B 保存的寄存器值加载到 CPU：</p>
<pre><code class="lang-c">void proc_load(context_t* ctx) {
    if (_current_proc == NULL)
        return;

    // 将进程 B 的 ctx 结构复制到 CPU 寄存器
    memcpy(ctx, &amp;_current_proc-&gt;ctx, sizeof(context_t));

    // 切换页表：加载进程 B 的虚拟地址空间
    mmu_switch_page_dir(_current_proc-&gt;space-&gt;vm);
}
</code></pre>
<p><strong>恢复的内容</strong>：</p>
<ol>
<li><strong>加载寄存器</strong>：将保存的 PC、SP、r0-r12 等值恢复到 CPU。</li>
<li><strong>切换页表</strong>：修改 MMU 的页表基址寄存器（ARM 中的 TTBR0），使 CPU 访问进程 B 的内存空间。</li>
<li><strong>刷新 TLB</strong>：页表切换后，TLB（Translation Lookaside Buffer）缓存失效，需要刷新。</li>
</ol>
<h4 id="第-5-步：继续执行"><strong>第 5 步：继续执行</strong></h4>
<p>CPU 从进程 B 的 PC 指向的位置继续执行。进程 B 感觉自己只是&quot;眨了一下眼&quot;，完全不知道被暂停过。</p>
<h3 id="上下文切换的开销">上下文切换的开销</h3>
<p>上下文切换看似简单，但实际开销不小：</p>
<h4 id="直接开销"><strong>直接开销</strong></h4>
<ol>
<li><strong>保存和加载寄存器</strong>：约 20-50 条指令，耗时 0.1-0.5 微秒。</li>
<li><strong>切换页表</strong>：修改 MMU 寄存器，耗时 0.1 微秒。</li>
<li><strong>刷新 TLB</strong>：清空地址转换缓存，耗时 1-5 微秒。</li>
<li><strong>调度器逻辑</strong>：遍历就绪队列，选择进程，耗时 0.5-2 微秒。</li>
</ol>
<p><strong>总直接开销</strong>：约 <strong>2-10 微秒</strong>。</p>
<h4 id="间接开销（更严重）"><strong>间接开销（更严重）</strong></h4>
<ol>
<li><strong>CPU 缓存失效</strong>：<ul>
<li>进程 A 使用的数据在 L1/L2 缓存中。</li>
<li>切换到进程 B 后，缓存被进程 B 的数据覆盖。</li>
<li>进程 A 恢复运行时，需要重新从内存加载数据。</li>
<li><strong>缓存冷启动 (Cold Cache)</strong> 导致性能下降 20-50%。</li>
</ul>
</li>
<li><strong>TLB 失效</strong>：<ul>
<li>TLB 缓存了虚拟地址到物理地址的映射。</li>
<li>切换页表后，TLB 完全失效。</li>
<li>后续内存访问需要重新查页表（慢 10-100 倍）。</li>
</ul>
</li>
<li><strong>流水线冲刷 (Pipeline Flush)</strong>：<ul>
<li>现代 CPU 使用指令流水线（10-20 级）。</li>
<li>上下文切换会导致流水线中的指令作废。</li>
<li>需要重新填充流水线，损失几十个时钟周期。</li>
</ul>
</li>
</ol>
<p><strong>总间接开销</strong>：可能导致后续数百到数千条指令执行变慢。</p>
<h4 id="实际影响"><strong>实际影响</strong></h4>
<ul>
<li>如果系统每秒切换 1000 次（每 1ms 一次），直接开销约占 1% CPU 时间。</li>
<li>但加上间接开销（缓存失效等），总开销可达 <strong>10-20% CPU 时间</strong>。</li>
<li>这就是为什么减少上下文切换频率是性能优化的重要方向。</li>
</ul>
<h3 id="上下文切换的优化策略">上下文切换的优化策略</h3>
<h4 id="1-减少切换频率"><strong>1. 减少切换频率</strong></h4>
<ul>
<li><strong>增加时间片</strong>：从 1ms 增加到 10ms，切换次数减少 10 倍。</li>
<li><strong>批量处理</strong>：等待多个事件再切换，而不是每个事件都切换。</li>
</ul>
<h4 id="2-cpu-亲和性-affinity"><strong>2. CPU 亲和性 (Affinity)</strong></h4>
<ul>
<li>让进程总是在同一个 CPU 核心运行。</li>
<li>减少缓存失效，提高性能 20-30%。</li>
</ul>
<h4 id="3-轻量级进程切换"><strong>3. 轻量级进程切换</strong></h4>
<ul>
<li>同一进程的多个线程切换时，不需要切换页表（共享地址空间）。</li>
<li>只需要保存和加载寄存器，开销降低 50%。</li>
</ul>
<h4 id="4-懒惰-tlb-刷新-lazy-tlb-flush"><strong>4. 懒惰 TLB 刷新 (Lazy TLB Flush)</strong></h4>
<ul>
<li>某些架构支持为每个进程分配 ASID (Address Space ID)。</li>
<li>切换进程时不刷新 TLB，通过 ASID 区分不同进程的 TLB 项。</li>
</ul>
<h3 id="微内核-vs-宏内核：上下文切换的差异">微内核 vs 宏内核：上下文切换的差异</h3>
<p>在微内核和宏内核中，上下文切换的意义和频率有显著差异。</p>
<h4 id="宏内核（如-linux）"><strong>宏内核（如 Linux）</strong></h4>
<ul>
<li><strong>特点</strong>：内核服务（文件系统、驱动）运行在内核态。</li>
<li><strong>系统调用开销</strong>：<ul>
<li>用户进程调用 <code>read()</code> 时，只需要从用户态切换到内核态（特权级切换）。</li>
<li>不需要进程切换，开销约 0.1-0.5 微秒。</li>
</ul>
</li>
<li><strong>优点</strong>：系统调用快速，适合频繁 I/O 的应用。</li>
</ul>
<h4 id="微内核（如-ewokos）"><strong>微内核（如 EwokOS）</strong></h4>
<ul>
<li><strong>特点</strong>：内核服务（VFS、驱动）运行为独立进程。</li>
<li><strong>系统调用开销</strong>：<ul>
<li>用户进程调用 <code>read()</code> 时，需要通过 IPC 发送消息给 VFS 进程。</li>
<li>涉及至少 2 次上下文切换：用户进程 → 内核 → VFS 进程。</li>
<li>开销约 5-20 微秒。</li>
</ul>
</li>
<li><strong>挑战</strong>：如何减少 IPC 和上下文切换的开销？</li>
<li><strong>优化方案</strong>：<ul>
<li><strong>零拷贝 IPC</strong>：通过共享内存传递数据，避免数据复制。</li>
<li><strong>批量 IPC</strong>：一次 IPC 处理多个请求。</li>
<li><strong>异步 IPC</strong>：发送消息后不等待响应，继续执行。</li>
</ul>
</li>
</ul>
<p><strong>EwokOS 的设计权衡</strong>：</p>
<ul>
<li>牺牲了部分性能（上下文切换频繁），但获得了：<ul>
<li><strong>隔离性</strong>：VFS 崩溃不会导致内核崩溃。</li>
<li><strong>可扩展性</strong>：可以热插拔驱动和服务。</li>
<li><strong>安全性</strong>：服务之间无法直接访问对方内存。</li>
</ul>
</li>
</ul>
<h3 id="上下文切换的实际测量">上下文切换的实际测量</h3>
<p>让我们看一个实际的测量例子（在 ARM Cortex-A 系列 CPU 上）：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>耗时（微秒）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>保存寄存器</td>
<td>0.2</td>
<td>约 30 条指令</td>
</tr>
<tr>
<td>加载寄存器</td>
<td>0.2</td>
<td>约 30 条指令</td>
</tr>
<tr>
<td>切换页表</td>
<td>0.1</td>
<td>修改 TTBR0</td>
</tr>
<tr>
<td>刷新 TLB</td>
<td>1-5</td>
<td>取决于 TLB 大小</td>
</tr>
<tr>
<td>调度决策</td>
<td>0.5-2</td>
<td>遍历就绪队列</td>
</tr>
<tr>
<td><strong>直接总开销</strong></td>
<td><strong>2-10</strong></td>
<td>-</td>
</tr>
<tr>
<td>L1 缓存失效</td>
<td>10-50</td>
<td>后续几百次内存访问变慢</td>
</tr>
<tr>
<td>L2 缓存失效</td>
<td>50-200</td>
<td>大量数据需要从内存加载</td>
</tr>
<tr>
<td><strong>间接总开销</strong></td>
<td><strong>60-250</strong></td>
<td>影响后续执行</td>
</tr>
</tbody>
</table>
<p><strong>结论</strong>：上下文切换的真实开销远大于表面看起来的 2-10 微秒，可能达到数百微秒。</p>
<h3 id="代码示例：完整的上下文切换">代码示例：完整的上下文切换</h3>
<p>下面是 EwokOS 中上下文切换的简化代码：</p>
<pre><code class="lang-c">// kernel/kernel/src/sched.c

void schedule(context_t* ctx) {
    // 1. 保存当前进程的上下文
    if (_current_proc != NULL) {
        memcpy(&amp;_current_proc-&gt;ctx, ctx, sizeof(context_t));
        _current_proc-&gt;info.state = READY;  // 改为就绪状态
    }

    // 2. 选择下一个进程
    _current_proc = proc_get_next_ready();

    // 3. 如果没有就绪进程，运行空闲进程
    if (_current_proc == NULL) {
        _current_proc = _idle_proc;
    }

    // 4. 更新进程状态
    _current_proc-&gt;info.state = RUNNING;

    // 5. 加载新进程的上下文
    memcpy(ctx, &amp;_current_proc-&gt;ctx, sizeof(context_t));

    // 6. 切换页表（切换虚拟地址空间）
    mmu_switch_page_dir(_current_proc-&gt;space-&gt;vm);

    // 7. 刷新 TLB
    __asm__ volatile(&quot;mcr p15, 0, %0, c8, c7, 0&quot; : : &quot;r&quot;(0));
}
</code></pre>
<p>这个函数虽然只有几十行代码，但它是操作系统最核心的部分之一。每秒可能被调用数千次，是系统性能的关键瓶颈。</p>
<h3 id="上下文切换：魔术背后的真相">上下文切换：魔术背后的真相</h3>
<p>上下文切换就像电影中的无缝剪辑——观众看到的是流畅的故事，但实际上导演在幕后做了大量工作（场景切换、演员调度、道具准备）。</p>
<p>操作系统通过上下文切换，让多个进程看起来&quot;同时&quot;运行。但这个魔术是有代价的——每次切换都消耗时间和资源。现代操作系统设计的一个重要目标，就是在提供良好多任务体验的同时，尽量减少上下文切换的开销。</p>
<h2 id="35-线程：轻量级的进程">3.5 线程：轻量级的进程</h2>
<p>如果进程是&quot;一道菜&quot;，<strong>线程 (Thread)</strong> 就是&quot;这道菜里的不同工序&quot;。洗菜、切菜、炒菜可以同时进行（如果有多核 CPU），它们共享同一个厨房（内存空间）和同一份食材（全局变量）。</p>
<p>但为什么我们需要线程？进程不是已经够用了吗？让我们来看看线程诞生的背景和它解决的问题。</p>
<h3 id="为什么需要线程？进程的三大痛点">为什么需要线程？进程的三大痛点</h3>
<h4 id="痛点-1：创建进程太慢、太重"><strong>痛点 1：创建进程太慢、太重</strong></h4>
<p><strong>场景</strong>：Web 服务器需要同时处理数千个客户端请求。</p>
<ul>
<li><strong>方案 1</strong>：为每个请求 <code>fork()</code> 一个新进程。</li>
<li><strong>问题</strong>：<ul>
<li><code>fork()</code> 需要复制进程的地址空间（即使使用 COW，仍需要复制页表）。</li>
<li>每个进程占用 2-4 MB 内存（栈 + 堆 + 代码）。</li>
<li>1000 个进程 = 2-4 GB 内存，小型服务器撑不住。</li>
<li>创建一个进程需要 100-500 微秒，创建 1000 个进程 = 100-500 毫秒。</li>
</ul>
</li>
</ul>
<h4 id="痛点-2：进程间通信（ipc）太复杂、太慢"><strong>痛点 2：进程间通信（IPC）太复杂、太慢</strong></h4>
<p><strong>场景</strong>：图形界面程序，需要一个线程负责 UI 渲染，另一个线程负责后台计算。</p>
<ul>
<li><strong>方案 1</strong>：使用两个进程 + IPC（如管道、共享内存）。</li>
<li><strong>问题</strong>：<ul>
<li>进程间通信需要通过内核，涉及上下文切换。</li>
<li>共享数据需要显式复制或设置共享内存，复杂度高。</li>
<li>IPC 开销约 5-20 微秒，频繁通信会成为瓶颈。</li>
</ul>
</li>
</ul>
<h4 id="痛点-3：进程切换开销太大"><strong>痛点 3：进程切换开销太大</strong></h4>
<p><strong>场景</strong>：需要在多个相关任务之间快速切换。</p>
<ul>
<li><strong>方案 1</strong>：使用多个进程。</li>
<li><strong>问题</strong>：<ul>
<li>每次进程切换需要切换页表，导致 TLB 和 CPU 缓存失效。</li>
<li>上下文切换开销约 5-20 微秒（加上间接开销可达数百微秒）。</li>
<li>频繁切换会严重影响性能。</li>
</ul>
</li>
</ul>
<h3 id="线程的解决方案">线程的解决方案</h3>
<p>线程的核心思想是：<strong>在同一个进程内，创建多个独立的执行流，共享同一个地址空间</strong>。</p>
<p><strong>线程的特点</strong>：</p>
<ol>
<li><strong>共享内存</strong>：所有线程共享进程的代码段、数据段、堆内存。</li>
<li><strong>独立栈</strong>：每个线程有自己独立的栈空间，用于保存局部变量和函数调用。</li>
<li><strong>独立上下文</strong>：每个线程有自己的寄存器状态（PC、SP、r0-r12 等）。</li>
<li><strong>共享资源</strong>：文件描述符、信号处理器等资源在线程间共享。</li>
</ol>
<p><strong>线程带来的好处</strong>：</p>
<ul>
<li><strong>创建快</strong>：创建线程只需分配栈空间和初始化上下文，耗时约 1-5 微秒（比进程快 100 倍）。</li>
<li><strong>通信简单</strong>：线程间直接读写共享内存，无需 IPC，零开销。</li>
<li><strong>切换快</strong>：线程切换不需要切换页表，只需保存/加载寄存器，开销降低 50-70%。</li>
</ul>
<h3 id="线程-vs-进程：详细对比">线程 vs 进程：详细对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>进程 (Process)</th>
<th>线程 (Thread)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>地址空间</strong></td>
<td>独立（隔离）</td>
<td>共享（同一进程内）</td>
</tr>
<tr>
<td><strong>创建开销</strong></td>
<td>100-500 微秒</td>
<td>1-5 微秒</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>2-4 MB</td>
<td>几十 KB（仅栈）</td>
</tr>
<tr>
<td><strong>切换开销</strong></td>
<td>5-20 微秒（需切换页表）</td>
<td>1-5 微秒（不切换页表）</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>IPC（管道、共享内存、消息队列）</td>
<td>直接访问共享内存</td>
</tr>
<tr>
<td><strong>通信开销</strong></td>
<td>5-20 微秒</td>
<td>几乎为零</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>强（崩溃不影响其他进程）</td>
<td>弱（一个线程崩溃可能导致整个进程崩溃）</td>
</tr>
<tr>
<td><strong>调试难度</strong></td>
<td>低（进程独立）</td>
<td>高（竞态条件、死锁）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>独立任务、需要隔离</td>
<td>协作任务、共享数据</td>
</tr>
</tbody>
</table>
<h3 id="线程的实现模型">线程的实现模型</h3>
<p>操作系统实现线程有三种主要模型：</p>
<h4 id="1-用户级线程-user-level-threads"><strong>1. 用户级线程 (User-Level Threads)</strong></h4>
<ul>
<li><strong>实现</strong>：线程由用户空间的库（如 Green Threads）管理，内核不知道线程的存在。</li>
<li><strong>调度</strong>：线程库实现调度器，在用户空间切换线程。</li>
<li><strong>优点</strong>：<ul>
<li>创建和切换极快（无需系统调用）。</li>
<li>可以在不支持线程的内核上运行。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>无法利用多核（内核只看到一个进程）。</li>
<li>一个线程阻塞（如 I/O），整个进程都阻塞。</li>
</ul>
</li>
<li><strong>例子</strong>：早期的 Java Green Threads（Java 1.2 之前）。</li>
</ul>
<h4 id="2-内核级线程-kernel-level-threads"><strong>2. 内核级线程 (Kernel-Level Threads)</strong></h4>
<ul>
<li><strong>实现</strong>：线程由内核管理，每个线程是内核调度的基本单位。</li>
<li><strong>调度</strong>：内核调度器直接调度线程，可以利用多核。</li>
<li><strong>优点</strong>：<ul>
<li>可以充分利用多核 CPU。</li>
<li>一个线程阻塞不影响其他线程。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>创建和切换需要系统调用，开销稍大。</li>
<li>线程数量受内核限制。</li>
</ul>
</li>
<li><strong>例子</strong>：Linux、Windows、macOS 的原生线程。</li>
</ul>
<h4 id="3-混合模型-hybrid-model---mn-threading"><strong>3. 混合模型 (Hybrid Model - M:N Threading)</strong></h4>
<ul>
<li><strong>实现</strong>：M 个用户级线程映射到 N 个内核级线程（M &gt; N）。</li>
<li><strong>调度</strong>：用户空间调度器 + 内核调度器两级调度。</li>
<li><strong>优点</strong>：<ul>
<li>兼顾用户级线程的快速创建和内核级线程的多核支持。</li>
<li>灵活性高。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>实现复杂，调试困难。</li>
<li>两级调度可能导致优先级倒置。</li>
</ul>
</li>
<li><strong>例子</strong>：Solaris 操作系统、Go 语言的 goroutine（现代实现）。</li>
</ul>
<h3 id="ewokos-中的线程实现">EwokOS 中的线程实现</h3>
<p>在 EwokOS 中，线程采用<strong>内核级线程</strong>模型，但实现非常简洁：</p>
<p><strong>核心思想</strong>：<strong>线程就是共享地址空间的进程</strong>。</p>
<pre><code class="lang-c">// 创建线程（简化版）
int thread_create(void (*entry)(void*), void* arg) {
    proc_t* thread = proc_alloc();

    // 1. 共享父进程的地址空间
    thread-&gt;space = _current_proc-&gt;space;
    space_add_ref(thread-&gt;space);  // 增加引用计数

    // 2. 分配独立的栈
    thread-&gt;ctx.sp = alloc_thread_stack();

    // 3. 设置入口点
    thread-&gt;ctx.pc = (uint32_t)entry;
    thread-&gt;ctx.r0 = (uint32_t)arg;  // 参数传递

    // 4. 其他设置（优先级、状态等）
    thread-&gt;info.priority = _current_proc-&gt;info.priority;
    thread-&gt;info.state = READY;

    // 5. 加入调度队列
    sched_add_ready(thread);

    return thread-&gt;info.pid;
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li><strong>共享 <code>space</code> 指针</strong>：所有线程指向同一个 <code>proc_space_t</code> 结构，共享页表。</li>
<li><strong>独立栈</strong>：每个线程有独立的栈空间（通常 8-64 KB）。</li>
<li><strong>独立上下文</strong>：每个线程有独立的 <code>ctx</code> 结构，保存寄存器状态。</li>
<li><strong>引用计数</strong>：使用引用计数管理共享地址空间，最后一个线程退出时才释放。</li>
</ul>
<h3 id="线程的经典应用场景">线程的经典应用场景</h3>
<h4 id="1-web-服务器"><strong>1. Web 服务器</strong></h4>
<pre><code class="lang-c">// 每个客户端连接由一个线程处理
void handle_client(void* socket_fd) {
    int fd = (int)socket_fd;
    while (1) {
        char buf[1024];
        int n = read(fd, buf, sizeof(buf));
        if (n &lt;= 0) break;

        // 处理请求
        process_request(buf, n);

        // 发送响应
        write(fd, response, response_len);
    }
    close(fd);
}

// 主线程
void server_main() {
    int listen_fd = socket(...);
    bind(listen_fd, ...);
    listen(listen_fd, ...);

    while (1) {
        int client_fd = accept(listen_fd, ...);
        thread_create(handle_client, (void*)client_fd);
    }
}
</code></pre>
<h4 id="2-gui-应用程序"><strong>2. GUI 应用程序</strong></h4>
<pre><code class="lang-c">// UI 线程：负责渲染界面，必须快速响应
void ui_thread() {
    while (1) {
        Event event = get_next_event();
        handle_event(event);
        render_frame();
    }
}

// 工作线程：负责耗时的后台任务
void worker_thread() {
    while (1) {
        Task task = get_next_task();
        process_task(task);
        update_ui(task.result);  // 通过共享内存通知 UI
    }
}
</code></pre>
<h4 id="3-并行计算"><strong>3. 并行计算</strong></h4>
<pre><code class="lang-c">// 图像处理：将图像分成 4 块，每块由一个线程处理
void process_image_chunk(void* arg) {
    ImageChunk* chunk = (ImageChunk*)arg;
    for (int y = chunk-&gt;start_y; y &lt; chunk-&gt;end_y; y++) {
        for (int x = 0; x &lt; chunk-&gt;width; x++) {
            chunk-&gt;pixels[y][x] = apply_filter(chunk-&gt;pixels[y][x]);
        }
    }
}

void process_image_parallel() {
    ImageChunk chunks[4];
    split_image(chunks);

    for (int i = 0; i &lt; 4; i++) {
        thread_create(process_image_chunk, &amp;chunks[i]);
    }

    wait_all_threads();
    merge_chunks(chunks);
}
</code></pre>
<h3 id="线程的挑战：并发-bug">线程的挑战：并发 Bug</h3>
<p>线程带来性能提升的同时，也引入了新的复杂性：</p>
<h4 id="1-竞态条件-race-condition"><strong>1. 竞态条件 (Race Condition)</strong></h4>
<pre><code class="lang-c">// 两个线程同时执行
int counter = 0;

void increment() {
    for (int i = 0; i &lt; 1000000; i++) {
        counter++;  // 不是原子操作！
    }
}

// 预期结果：counter = 2000000
// 实际结果：counter = 1234567（小于预期）
</code></pre>
<p><strong>原因</strong>：<code>counter++</code> 实际上是三条指令：</p>
<ol>
<li>从内存读取 <code>counter</code> 到寄存器。</li>
<li>寄存器加 1。</li>
<li>写回内存。</li>
</ol>
<p>如果两个线程交替执行，可能出现：</p>
<pre><code>线程 A: 读取 counter = 0
线程 B: 读取 counter = 0
线程 A: 加 1 → 1
线程 B: 加 1 → 1
线程 A: 写回 counter = 1
线程 B: 写回 counter = 1
结果：counter = 1（应该是 2）
</code></pre><p><strong>解决方案</strong>：使用互斥锁 (Mutex)。</p>
<h4 id="2-死锁-deadlock"><strong>2. 死锁 (Deadlock)</strong></h4>
<pre><code class="lang-c">mutex_t lock_A, lock_B;

void thread_1() {
    lock(lock_A);
    sleep(1);  // 模拟延迟
    lock(lock_B);
    // 临界区
    unlock(lock_B);
    unlock(lock_A);
}

void thread_2() {
    lock(lock_B);
    sleep(1);
    lock(lock_A);
    // 临界区
    unlock(lock_A);
    unlock(lock_B);
}

// 结果：线程 1 持有 A 等待 B，线程 2 持有 B 等待 A，死锁！
</code></pre>
<p><strong>解决方案</strong>：</p>
<ul>
<li>总是以相同的顺序获取锁。</li>
<li>使用超时机制。</li>
<li>死锁检测算法。</li>
</ul>
<h4 id="3-优先级反转-priority-inversion"><strong>3. 优先级反转 (Priority Inversion)</strong></h4>
<pre><code class="lang-c">// 高优先级线程 H 等待低优先级线程 L 释放锁
// 但中优先级线程 M 抢占了 L，导致 H 被 M 间接阻塞
</code></pre>
<p><strong>著名案例</strong>：1997 年火星探路者号因优先级反转导致系统重启。</p>
<p><strong>解决方案</strong>：优先级继承协议（持锁的低优先级线程临时提升到等待者的优先级）。</p>
<h3 id="微内核-vs-宏内核：线程的差异">微内核 vs 宏内核：线程的差异</h3>
<h4 id="宏内核（linux）中的线程"><strong>宏内核（Linux）中的线程</strong></h4>
<ul>
<li><strong>实现</strong>：线程通过 <code>clone()</code> 系统调用创建，本质上是共享资源的轻量级进程。</li>
<li><strong>调度</strong>：内核调度器统一调度进程和线程，无区别对待。</li>
<li><strong>特点</strong>：<ul>
<li>线程创建开销约 5-10 微秒。</li>
<li>线程切换开销约 1-3 微秒。</li>
<li>线程数量可达数万（受内存限制）。</li>
</ul>
</li>
</ul>
<h4 id="微内核（ewokos）中的线程"><strong>微内核（EwokOS）中的线程</strong></h4>
<ul>
<li><strong>实现</strong>：线程是共享地址空间的进程，实现简洁。</li>
<li><strong>调度</strong>：与进程使用相同的调度器。</li>
<li><strong>设计考量</strong>：<ul>
<li><strong>服务进程通常单线程</strong>：VFS、驱动等系统服务通常不使用多线程，因为：<ul>
<li>微内核强调简单性和可靠性。</li>
<li>多线程增加复杂性和 Bug 风险。</li>
<li>多进程隔离更安全（一个服务崩溃不影响其他服务）。</li>
</ul>
</li>
<li><strong>应用程序可以多线程</strong>：用户应用可以自由使用多线程提升性能。</li>
</ul>
</li>
<li><strong>权衡</strong>：<ul>
<li>牺牲了部分并发性（服务进程单线程），但换取了更高的稳定性和安全性。</li>
<li>在需要并发的场景，可以使用异步 I/O 或事件驱动模型代替多线程。</li>
</ul>
</li>
</ul>
<h3 id="线程的未来：协程和异步编程">线程的未来：协程和异步编程</h3>
<p>随着编程语言的发展，出现了更轻量级的并发模型：</p>
<h4 id="协程-coroutine"><strong>协程 (Coroutine)</strong></h4>
<ul>
<li><strong>概念</strong>：用户空间的轻量级线程，可以主动让出 CPU（yield）。</li>
<li><strong>优点</strong>：<ul>
<li>创建开销极低（几纳秒）。</li>
<li>切换开销极低（几纳秒）。</li>
<li>可以创建数百万个协程。</li>
</ul>
</li>
<li><strong>例子</strong>：Go 的 goroutine、Python 的 async/await、Kotlin 的 coroutine。</li>
</ul>
<h4 id="异步-io--事件循环"><strong>异步 I/O + 事件循环</strong></h4>
<ul>
<li><strong>概念</strong>：单线程 + 非阻塞 I/O + 事件驱动。</li>
<li><strong>优点</strong>：<ul>
<li>避免线程同步问题。</li>
<li>高并发（单线程处理数千连接）。</li>
</ul>
</li>
<li><strong>例子</strong>：Node.js、Nginx、Redis。</li>
</ul>
<p>这些现代并发模型在某些场景下比传统线程更高效，但它们的实现仍然依赖于操作系统的进程和线程机制。</p>
<h3 id="总结：线程的定位">总结：线程的定位</h3>
<p>线程是进程和协程之间的中间层：</p>
<ul>
<li>比进程轻量，适合共享数据的并发任务。</li>
<li>比协程重量，但由内核调度，可以利用多核。</li>
</ul>
<p>在 EwokOS 这样的微内核中，线程的设计哲学是：<strong>简单、高效、够用</strong>。不追求最复杂的功能，而是提供清晰、可靠的抽象，为上层应用提供坚实的基础。</p>
<h2 id="36-微内核-vs-宏内核：进程管理的设计差异">3.6 微内核 vs 宏内核：进程管理的设计差异</h2>
<p>在深入理解了进程和线程的核心概念后，让我们从更高的视角审视：<strong>微内核（如 EwokOS）和宏内核（如 Linux）在进程管理上有哪些设计差异？为什么要这样设计？</strong></p>
<h3 id="架构差异：进程的角色定位">架构差异：进程的角色定位</h3>
<h4 id="宏内核（linux）的进程模型"><strong>宏内核（Linux）的进程模型</strong></h4>
<p>在宏内核中，进程主要用于<strong>用户应用</strong>，而系统服务（文件系统、网络协议栈、设备驱动）都运行在<strong>内核态</strong>，以内核模块或内核线程的形式存在。</p>
<pre><code>用户空间：
  [应用 A] [应用 B] [应用 C]
       |       |       |
    系统调用 (syscall)
       |       |       |
-------+-------+-------+-------- 特权级分界线
       v       v       v
内核空间：
  [VFS] [网络栈] [调度器] [内存管理] [驱动 1] [驱动 2]
  （都在同一个地址空间，可以直接函数调用）
</code></pre><p><strong>特点</strong>：</p>
<ul>
<li><strong>进程 = 用户应用</strong>：系统服务不是进程。</li>
<li><strong>高性能</strong>：系统调用只需特权级切换（0.1-0.5 微秒），不需要进程切换。</li>
<li><strong>低隔离</strong>：驱动崩溃会导致整个内核崩溃（蓝屏/Kernel Panic）。</li>
</ul>
<h4 id="微内核（ewokos）的进程模型"><strong>微内核（EwokOS）的进程模型</strong></h4>
<p>在微内核中，<strong>一切皆进程</strong>。不仅用户应用是进程，文件系统、网络协议栈、设备驱动也都是独立的进程，运行在用户空间。</p>
<pre><code>用户空间：
  [应用 A] [应用 B] [VFS 进程] [网络进程] [驱动 1 进程] [驱动 2 进程]
       |       |         |          |            |             |
       +-------+---------+----------+------------+-------------+
                          |
                        IPC 消息
                          |
       -------------------v-------------------- 特权级分界线
                          |
内核空间（极简）：
  [调度器] [IPC 机制] [内存管理] [中断处理]
  （只有最核心的功能）
</code></pre><p><strong>特点</strong>：</p>
<ul>
<li><strong>进程 = 应用 + 服务</strong>：系统服务也是进程。</li>
<li><strong>强隔离</strong>：VFS 崩溃只影响文件操作，不会导致内核崩溃。</li>
<li><strong>高开销</strong>：系统调用需要 IPC + 进程切换（5-20 微秒），比宏内核慢 10-40 倍。</li>
</ul>
<h3 id="进程创建：fork-的实现差异">进程创建：fork() 的实现差异</h3>
<h4 id="宏内核（linux）的-fork"><strong>宏内核（Linux）的 fork()</strong></h4>
<pre><code class="lang-c">// Linux 的 fork() 实现（简化）
pid_t do_fork() {
    // 1. 分配新的 task_struct（进程描述符）
    task_struct* child = alloc_task_struct();

    // 2. 复制父进程的资源
    copy_mm(child, current);        // 内存空间（COW）
    copy_files(child, current);     // 文件描述符
    copy_signals(child, current);   // 信号处理
    copy_namespaces(child, current);// 命名空间（容器隔离）

    // 3. 分配 PID
    child-&gt;pid = alloc_pid();

    // 4. 加入调度队列
    wake_up_new_task(child);

    return child-&gt;pid;
}
</code></pre>
<p><strong>开销</strong>：约 100-500 微秒（取决于进程大小）。</p>
<p><strong>优化</strong>：</p>
<ul>
<li><strong>写时复制 (COW)</strong>：不立即复制内存，延迟到真正写入时。</li>
<li><strong>vfork()</strong>：共享父进程内存，子进程立即 <code>exec()</code>，避免复制。</li>
<li><strong>clone()</strong>：允许选择性共享资源（内存、文件、信号等），用于创建线程。</li>
</ul>
<h4 id="微内核（ewokos）的-fork"><strong>微内核（EwokOS）的 fork()</strong></h4>
<pre><code class="lang-c">// EwokOS 的 fork() 实现（简化）
int proc_fork() {
    // 1. 分配新的 proc_t
    proc_t* child = proc_alloc();

    // 2. 复制地址空间（COW）
    child-&gt;space = proc_space_clone(current-&gt;space);

    // 3. 复制上下文
    memcpy(&amp;child-&gt;ctx, ¤t-&gt;ctx, sizeof(context_t));
    child-&gt;ctx.r0 = 0;  // fork() 在子进程中返回 0

    // 4. 分配 PID
    child-&gt;info.pid = proc_alloc_pid();
    child-&gt;info.ppid = current-&gt;info.pid;

    // 5. 加入就绪队列
    child-&gt;info.state = READY;
    sched_add_ready(child);

    return child-&gt;info.pid;  // 父进程中返回子进程 PID
}
</code></pre>
<p><strong>开销</strong>：约 50-200 微秒（比 Linux 稍快，因为内核更简单）。</p>
<p><strong>区别</strong>：</p>
<ul>
<li>EwokOS 的 <code>fork()</code> 更纯粹：只复制进程本身，不涉及命名空间、cgroup 等复杂特性。</li>
<li>Linux 的 <code>fork()</code> 更灵活：支持容器、资源限制等高级功能。</li>
</ul>
<h3 id="调度器：设计哲学的不同">调度器：设计哲学的不同</h3>
<h4 id="宏内核（linux）的-cfs-调度器"><strong>宏内核（Linux）的 CFS 调度器</strong></h4>
<p>Linux 使用 <strong>完全公平调度器 (CFS, Completely Fair Scheduler)</strong>，追求绝对的公平性。</p>
<p><strong>核心思想</strong>：</p>
<ul>
<li>每个进程都应该获得 <code>1/N</code> 的 CPU 时间（N 是进程数）。</li>
<li>使用红黑树跟踪每个进程的&quot;虚拟运行时间&quot; (<code>vruntime</code>)。</li>
<li>总是选择 <code>vruntime</code> 最小的进程运行。</li>
</ul>
<p><strong>复杂度</strong>：</p>
<ul>
<li>插入/删除进程：O(log N)</li>
<li>选择下一个进程：O(1)（红黑树最小值缓存）</li>
<li>代码量：约 3000 行</li>
</ul>
<p><strong>优点</strong>：极其公平，适合通用桌面和服务器。
<strong>缺点</strong>：实现复杂，不适合硬实时系统。</p>
<h4 id="微内核（ewokos）的优先级调度器"><strong>微内核（EwokOS）的优先级调度器</strong></h4>
<p>EwokOS 使用 <strong>优先级调度 (Priority Scheduling)</strong>，追求简单性和可预测性。</p>
<p><strong>核心思想</strong>：</p>
<ul>
<li>每个进程有固定优先级（0-31，数字越小优先级越高）。</li>
<li>总是选择优先级最高的 READY 进程运行。</li>
<li>使用简单的链表或数组实现就绪队列。</li>
</ul>
<p><strong>复杂度</strong>：</p>
<ul>
<li>插入进程：O(1)</li>
<li>选择下一个进程：O(N)（遍历查找最高优先级）</li>
<li>代码量：约 200 行</li>
</ul>
<p><strong>优点</strong>：实现简单，可预测性强，适合嵌入式和实时系统。
<strong>缺点</strong>：低优先级进程可能饿死（需要优先级老化机制）。</p>
<p><strong>为什么选择优先级调度？</strong></p>
<ul>
<li><strong>简单即美</strong>：微内核强调最小化内核复杂度。</li>
<li><strong>实时性优先</strong>：嵌入式系统通常需要确定性响应时间。</li>
<li><strong>易于理解</strong>：教学和学习更容易。</li>
</ul>
<h3 id="进程间通信（ipc）：最大的差异">进程间通信（IPC）：最大的差异</h3>
<p>这是微内核和宏内核最根本的区别。</p>
<h4 id="宏内核（linux）的-ipc"><strong>宏内核（Linux）的 IPC</strong></h4>
<p>在 Linux 中，IPC 主要用于<strong>用户进程之间</strong>的通信。内核内部直接函数调用。</p>
<p><strong>IPC 机制</strong>：</p>
<ul>
<li><strong>管道 (Pipe)</strong>：单向字节流，适合父子进程。</li>
<li><strong>Socket</strong>：网络通信，也可用于本地 IPC（Unix Domain Socket）。</li>
<li><strong>共享内存</strong>：最快的 IPC，但需要额外的同步机制（信号量、互斥锁）。</li>
<li><strong>消息队列</strong>：异步消息传递，POSIX 或 System V 风格。</li>
<li><strong>信号 (Signal)</strong>：轻量级异步通知。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>IPC 是可选的：内核不依赖 IPC。</li>
<li>性能开销中等：共享内存几乎零开销，管道约 1-5 微秒。</li>
</ul>
<h4 id="微内核（ewokos）的-ipc"><strong>微内核（EwokOS）的 IPC</strong></h4>
<p>在 EwokOS 中，IPC 是<strong>核心机制</strong>，整个系统架构都建立在 IPC 之上。</p>
<p><strong>IPC 是必需的</strong>：</p>
<ul>
<li>应用调用文件系统：需要 IPC。</li>
<li>驱动返回数据：需要 IPC。</li>
<li>服务之间协作：需要 IPC。</li>
</ul>
<p><strong>EwokOS 的 IPC 实现</strong>：</p>
<ul>
<li><strong>同步 IPC</strong>：<code>ipc_call()</code> - 发送消息并等待响应（类似函数调用）。</li>
<li><strong>异步 IPC</strong>：<code>ipc_send()</code> - 发送消息后立即返回，稍后接收响应。</li>
<li><strong>共享内存</strong>：零拷贝传递大数据块（如文件内容）。</li>
</ul>
<p><strong>性能挑战</strong>：</p>
<ul>
<li>每次 IPC 涉及 2-4 次上下文切换：<pre><code>应用进程 → 内核 → 服务进程 → 内核 → 应用进程
</code></pre></li>
<li>开销约 5-20 微秒（比 Linux 系统调用慢 10-40 倍）。</li>
</ul>
<p><strong>优化策略</strong>：</p>
<ul>
<li><strong>零拷贝 IPC</strong>：通过共享内存传递数据，避免复制。</li>
<li><strong>批量 IPC</strong>：一次消息携带多个请求。</li>
<li><strong>缓存</strong>：服务进程缓存常用数据（如元数据）。</li>
</ul>
<p><strong>为什么接受这个开销？</strong></p>
<ul>
<li><strong>隔离性</strong>：驱动崩溃不会影响内核。</li>
<li><strong>安全性</strong>：服务之间完全隔离，无法直接访问对方内存。</li>
<li><strong>可扩展性</strong>：可以热插拔服务和驱动。</li>
<li><strong>简洁性</strong>：内核只关注核心功能（调度、IPC、内存），其他功能外置。</li>
</ul>
<h3 id="进程生命周期管理：细节差异">进程生命周期管理：细节差异</h3>
<h4 id="僵尸进程处理"><strong>僵尸进程处理</strong></h4>
<p><strong>Linux</strong>：</p>
<ul>
<li>父进程通过 <code>wait()</code> 回收子进程。</li>
<li>如果父进程退出，孤儿进程会被 init (PID 1) 收养。</li>
<li>init 会定期调用 <code>wait()</code> 回收所有僵尸进程。</li>
</ul>
<p><strong>EwokOS</strong>：</p>
<ul>
<li><p>类似机制，但更简单：</p>
<pre><code class="lang-c">// 父进程退出时
void proc_exit(int exit_code) {
    // 1. 将所有子进程的 PPID 改为 1
    for (int i = 0; i &lt; MAX_PROCS; i++) {
        if (procs[i].info.ppid == current-&gt;info.pid) {
            procs[i].info.ppid = 1;
        }
    }

    // 2. 标记为 ZOMBIE
    current-&gt;info.state = ZOMBIE;
    current-&gt;info.exit_code = exit_code;

    // 3. 通知父进程（发送 SIGCHLD）
    proc_signal(current-&gt;info.ppid, SIGCHLD);

    // 4. 调度其他进程
    schedule(get_context());
}
</code></pre>
</li>
</ul>
<h4 id="进程优先级管理"><strong>进程优先级管理</strong></h4>
<p><strong>Linux</strong>：</p>
<ul>
<li>支持动态优先级调整（nice 值：-20 到 19）。</li>
<li>支持实时优先级（SCHED_FIFO、SCHED_RR）。</li>
<li>支持 cgroup 资源限制。</li>
</ul>
<p><strong>EwokOS</strong>：</p>
<ul>
<li>只支持静态优先级（通常不动态调整）。</li>
<li>实时任务通过高优先级实现。</li>
<li>简单直接，易于预测。</li>
</ul>
<h3 id="多核支持：规模的差异">多核支持：规模的差异</h3>
<h4 id="linux-的多核调度"><strong>Linux 的多核调度</strong></h4>
<ul>
<li>支持数百个 CPU 核心（服务器级）。</li>
<li>使用 Per-CPU 运行队列 + 全局负载均衡。</li>
<li>支持 NUMA（非统一内存访问）优化。</li>
<li>支持 CPU 热插拔。</li>
</ul>
<h4 id="ewokos-的多核调度"><strong>EwokOS 的多核调度</strong></h4>
<ul>
<li>通常支持 2-8 个核心（嵌入式级）。</li>
<li>使用 Per-CPU 就绪队列 + 简单的工作窃取。</li>
<li>不考虑 NUMA（嵌入式系统通常是 UMA）。</li>
<li>简化的核心管理。</li>
</ul>
<p><strong>为什么规模不同？</strong></p>
<ul>
<li><strong>目标平台</strong>：Linux 针对服务器和桌面，EwokOS 针对嵌入式。</li>
<li><strong>设计哲学</strong>：Linux 追求通用性，EwokOS 追求简洁性。</li>
</ul>
<h3 id="线程实现：一致的抽象，不同的优先级">线程实现：一致的抽象，不同的优先级</h3>
<h4 id="linux-的线程"><strong>Linux 的线程</strong></h4>
<ul>
<li>通过 <code>pthread</code> 库（基于 <code>clone()</code> 系统调用）。</li>
<li>内核调度器统一调度进程和线程（NPTL - Native POSIX Thread Library）。</li>
<li>广泛用于高并发应用（Web 服务器、数据库）。</li>
</ul>
<h4 id="ewokos-的线程"><strong>EwokOS 的线程</strong></h4>
<ul>
<li>实现机制相同：共享地址空间的进程。</li>
<li>但使用场景不同：<ul>
<li><strong>系统服务通常单线程</strong>：VFS、驱动等服务避免使用多线程，降低复杂性。</li>
<li><strong>用户应用可以多线程</strong>：图形界面、游戏等应用自由使用。</li>
</ul>
</li>
</ul>
<p><strong>为什么服务进程单线程？</strong></p>
<ul>
<li><strong>简单性</strong>：多线程增加同步复杂度，容易引入 Bug。</li>
<li><strong>隔离性</strong>：多进程隔离 &gt; 多线程共享，更符合微内核哲学。</li>
<li><strong>稳定性</strong>：单线程服务更容易测试和验证。</li>
<li><strong>异步替代</strong>：使用事件驱动模型（如 epoll）代替多线程，单线程也能高并发。</li>
</ul>
<h3 id="设计权衡总结">设计权衡总结</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>宏内核（Linux）</th>
<th>微内核（EwokOS）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进程定位</strong></td>
<td>主要是用户应用</td>
<td>应用 + 系统服务</td>
</tr>
<tr>
<td><strong>系统调用开销</strong></td>
<td>0.1-0.5 微秒</td>
<td>5-20 微秒</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>低（驱动在内核态）</td>
<td>高（驱动是独立进程）</td>
</tr>
<tr>
<td><strong>调度算法</strong></td>
<td>CFS（复杂、公平）</td>
<td>优先级（简单、可预测）</td>
</tr>
<tr>
<td><strong>IPC 重要性</strong></td>
<td>可选（用户进程间）</td>
<td>核心（整个系统依赖）</td>
</tr>
<tr>
<td><strong>多核规模</strong></td>
<td>数百核</td>
<td>2-8 核</td>
</tr>
<tr>
<td><strong>线程使用</strong></td>
<td>广泛（应用+内核）</td>
<td>选择性（主要是应用）</td>
</tr>
<tr>
<td><strong>代码复杂度</strong></td>
<td>高（数百万行）</td>
<td>低（数万行）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高（系统调用快）</td>
<td>中（IPC 开销）</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>中（驱动 Bug 影响内核）</td>
<td>高（服务隔离）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>通用（桌面、服务器）</td>
<td>嵌入式、实时、教学</td>
</tr>
</tbody>
</table>
<h3 id="结论：没有绝对的优劣，只有适合的选择">结论：没有绝对的优劣，只有适合的选择</h3>
<ul>
<li><strong>宏内核（Linux）</strong>：牺牲了部分隔离性和简洁性，换取更高的性能和灵活性。适合通用计算场景。</li>
<li><strong>微内核（EwokOS）</strong>：牺牲了部分性能，换取更高的可靠性、安全性和简洁性。适合嵌入式、实时和教学场景。</li>
</ul>
<p>两种设计都是工程权衡的结果，没有绝对的优劣。理解它们的差异，能帮助我们在不同场景下做出更明智的选择。</p>
<h2 id="37-本章小结与展望">3.7 本章小结与展望</h2>
<p>我们刚刚完成了一次深入操作系统心脏的旅程。让我们回顾一下学到的核心概念：</p>
<ul>
<li><strong>进程抽象</strong>：Unix 在 1969 年发明的革命性概念，让多个程序可以&quot;同时&quot;运行在单个 CPU 上。</li>
<li><strong>进程状态</strong>：从 NEW 到 READY，再到 RUNNING、WAIT/BLOCK，最后到 ZOMBIE，每个进程都经历着生命周期。</li>
<li><strong>进程数据结构</strong>：<code>proc_t</code> 中的每个字段都有其特定用途，缺一不可。</li>
<li><strong>调度算法</strong>：从最简单的 FCFS 到现代的 CFS，操作系统一直在追求更公平、更高效的 CPU 分配。</li>
<li><strong>多核调度</strong>：如何让多个 CPU 核心高效协作而不互相干扰，这是现代操作系统必须面对的难题。</li>
<li><strong>上下文切换</strong>：操作系统最核心的魔术，让多个进程看起来同时运行，但代价是 10-20% 的性能开销。</li>
<li><strong>线程</strong>：比进程更轻量，适合共享数据的并发任务，但引入了竞态条件、死锁等新挑战。</li>
<li><strong>微内核 vs 宏内核</strong>：两种不同的设计哲学，各有优劣，适用于不同场景。</li>
</ul>
<p>但这里有一个关键问题我们还没有回答：在微内核架构中，所有的服务（VFS、驱动等）都是独立的进程，它们有自己独立的内存空间。那么，<strong>Shell 如何告诉 VFS&quot;我要读取文件&quot;？驱动如何把数据返回给应用程序？</strong></p>
<p>在宏内核中，这很简单——大家都在同一个内存空间，直接调用函数就行了。但在微内核中，进程之间是完全隔离的，不能直接访问对方的内存。这就需要一个特殊的机制来传递消息和数据。</p>
<p><strong>这就是下一章的主题——IPC（进程间通信）</strong>。我们将看到：</p>
<ul>
<li>微内核如何像一个高效的邮局，在进程之间传递消息。</li>
<li>同步 IPC 和异步 IPC 的区别——打电话 vs 发邮件。</li>
<li>共享内存如何实现零拷贝的高效数据传输。</li>
<li>IPC 如何成为微内核架构的&quot;神经系统&quot;。</li>
<li>如何优化 IPC 性能，弥补与宏内核的差距。</li>
</ul>
<p>进程管理解决了&quot;谁来用 CPU&quot;的问题，而 IPC 将解决&quot;进程之间如何协作&quot;的问题。让我们继续探索。</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chapter2_arch.html" class="navigation navigation-prev " aria-label="Previous page: 第二章：EwokOS - 小内核，大梦想">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chapter4_ipc.html" class="navigation navigation-next " aria-label="Next page: 第四章：喂，听得见吗？ - IPC">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"第三章：幕后黑手 - 进程与线程","level":"1.4","depth":1,"next":{"title":"第四章：喂，听得见吗？ - IPC","level":"1.5","depth":1,"path":"chapter4_ipc.md","ref":"chapter4_ipc.md","articles":[]},"previous":{"title":"第二章：EwokOS - 小内核，大梦想","level":"1.3","depth":1,"path":"chapter2_arch.md","ref":"chapter2_arch.md","articles":[]},"dir":"ltr"},"config":{"plugins":["mermaid"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"mermaid":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Misa.Z","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"EwokOS Microkernel Booklet","language":"zh-hans","gitbook":"*","description":"A deep dive into the EwokOS microkernel."},"file":{"path":"chapter3_proc.md","mtime":"2025-11-24T17:05:55.955Z","type":"markdown"},"gitbook":{"version":"4.0.8","time":"2025-11-24T17:06:05.210Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/honkit-plugin-mermaid/mermaid-load.js"></script>
        
    
        
        <script src="gitbook/honkit-plugin-mermaid/mermaid.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

