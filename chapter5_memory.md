# 第五章：包租公 - 内存管理

## 5.1 虚拟内存：黑客帝国的矩阵

你以为你拥有整个世界，其实你只是生活在一个虚拟的矩阵里。
对于进程来说，也是如此。

每个进程都觉得自己拥有完整的 4GB 内存（在 32 位系统上）。它想读哪里就读哪里，想写哪里就写哪里。
但实际上，这只是操作系统给它编织的**虚拟内存 (Virtual Memory)** 幻象。

真正的物理内存（RAM）可能只有 1GB，而且被几十个进程瓜分得七零八落。

## 5.2 分页：把世界切成小块

操作系统是怎么做到这一点的呢？答案是**分页 (Paging)**。

它把内存切成一块块大小相等的小方块，通常是 4KB，叫做**页 (Page)**。
*   **虚拟页 (Virtual Page)**：进程看到的页。
*   **物理页 (Physical Page)**：内存条上真正的页。

操作系统维护着一本**页表 (Page Table)**，就像一个巨大的映射字典：
*   进程 A 的第 1 页 -> 物理内存的第 100 页
*   进程 A 的第 2 页 -> 物理内存的第 5 页
*   进程 B 的第 1 页 -> 物理内存的第 200 页

## 5.3 MMU：幕后的魔术师

谁来负责查字典呢？如果每次读写内存都要软件去查字典，那太慢了。
CPU 里有一个专门的硬件组件，叫做 **MMU (Memory Management Unit，内存管理单元)**。

1.  进程发出指令：读取虚拟地址 `0x1000`。
2.  MMU 拦截指令，查看当前的页表。
3.  MMU 发现 `0x1000` 对应物理地址 `0x5000`。
4.  MMU 偷偷把地址替换成 `0x5000`，去访问物理内存。
5.  进程完全不知道发生了什么，它以为自己真的读了 `0x1000`。

## 5.4 缺页异常：空头支票

有时候，进程想访问一个页面，但 MMU 发现页表里没有记录（或者标记为“不在内存中”）。
这时，MMU 会大喊一声：“停！出错了！” 这就是 **缺页异常 (Page Fault)**。

操作系统听到喊声，赶紧跑过来处理：
1.  **懒加载 (Lazy Allocation)**：进程申请了内存，但操作系统为了省事，先开个空头支票（只分配虚拟地址，不给物理页）。等进程真的要用了，触发缺页异常，操作系统才赶紧找一块物理页补上。
2.  **交换 (Swapping)**：内存不够了，操作系统把很久不用的页写到硬盘上（Swap 分区），腾出空间。等进程又要用时，再从硬盘读回来。

## 5.5 EwokOS 的内存管理

EwokOS 的内存管理代码主要在 `kernel/kernel/src/mm` 目录下。
它实现了基本的页表映射和内存分配 (`kmalloc`/`kfree`)。

每个进程都有自己的页目录 (`proc_t->space->vm`)。当切换进程时，内核会告诉 MMU：“换字典了！现在用进程 B 的页表。”

这样，进程 A 就算把自己的虚拟内存写烂了，也绝对影响不到进程 B 的物理内存。这就是**内存保护**。

下一章，我们将看看那些在用户空间辛勤工作的“打工仔”——驱动程序。

**核心内存管理模块**：
```
kernel/kernel/src/mm/
├── mmu.c          # MMU 配置和页表操作
├── kmalloc.c      # 内核内存分配器
├── kalloc.c       # 物理页帧分配器
├── shm.c          # 共享内存实现
├── trunkmem.c     # 大块内存管理
└── vm.c           # 虚拟内存管理
```

## 5.6 写时复制 (COW) 实现细节

**写时复制**是 EwokOS 的一个重要优化。当进程 `fork()` 时：

1.  **创建子进程**：复制 `proc_t` 结构，但**不复制物理页**。
2.  **标记只读**：将父子进程的所有可写页面都标记为**只读**。
3.  **共享页表**：父子进程的页表都指向同一块物理内存。
4.  **触发缺页**：当其中一个进程试图写入时，MMU 发现页面是只读的，触发**缺页异常**。
5.  **复制页面**：内核的缺页处理程序分配一个新的物理页，复制内容，更新页表。
6.  **恢复写权限**：将新页面标记为可读写，继续执行。

**关键代码** (`kernel/kernel/src/mm/vm.c`)：
```c
// fork 时设置 COW
void vm_set_cow(proc_t* proc) {
    for (每个可写页面) {
        标记为只读;
        设置 COW 标志位;
    }
}

// 缺页处理
void handle_page_fault(uint32_t addr) {
    if (页面标记为 COW) {
        分配新物理页;
        复制内容;
        更新页表，标记为可写;
        清除 COW 标志;
    }
}
```

**优势**：
*   大部分情况下，子进程只读取父进程的数据，不需要真正复制。
*   `fork()` 后立即 `exec()` 的场景（如 Shell 启动程序），根本不需要复制内存。
*   节省内存，加快进程创建速度。

## 5.7 内存布局

EwokOS 的进程虚拟内存布局（32 位为例）：

```
0xFFFFFFFF +------------------+
           |   内核空间       | (1GB)
           |  (所有进程共享)  |
0xC0000000 +------------------+
           |    用户栈        | (向下增长)
           |       ↓          |
           ~  - - - - - - -  ~
           |       ↑          |
           |    用户堆        | (向上增长)
           +------------------+
           |  .bss (未初始化) |
           +------------------+
           | .data (已初始化) |
           +------------------+
           |    .text (代码)  |
0x00010000 +------------------+
           |   保留区域       |
0x00000000 +------------------+
```

**64 位系统**则有更大的地址空间，布局类似但地址范围扩大。
