# 第五章：包租公 - 内存管理

## 5.1 虚拟内存：黑客帝国的矩阵

你以为你拥有整个世界，其实你只是生活在一个虚拟的矩阵里。
对于进程来说，也是如此。

每个进程都觉得自己拥有完整的 4GB 内存（在 32 位系统上）。它想读哪里就读哪里，想写哪里就写哪里。
但实际上，这只是操作系统给它编织的**虚拟内存 (Virtual Memory)** 幻象。

真正的物理内存（RAM）可能只有 1GB，而且被几十个进程瓜分得七零八落。

## 5.2 分页：把世界切成小块

操作系统是怎么做到这一点的呢？答案是**分页 (Paging)**。

它把内存切成一块块大小相等的小方块，通常是 4KB，叫做**页 (Page)**。
*   **虚拟页 (Virtual Page)**：进程看到的页。
*   **物理页 (Physical Page)**：内存条上真正的页。

操作系统维护着一本**页表 (Page Table)**，就像一个巨大的映射字典：
*   进程 A 的第 1 页 -> 物理内存的第 100 页
*   进程 A 的第 2 页 -> 物理内存的第 5 页
*   进程 B 的第 1 页 -> 物理内存的第 200 页

## 5.3 MMU：幕后的魔术师

谁来负责查字典呢？如果每次读写内存都要软件去查字典，那太慢了。
CPU 里有一个专门的硬件组件，叫做 **MMU (Memory Management Unit，内存管理单元)**。

1.  进程发出指令：读取虚拟地址 `0x1000`。
2.  MMU 拦截指令，查看当前的页表。
3.  MMU 发现 `0x1000` 对应物理地址 `0x5000`。
4.  MMU 偷偷把地址替换成 `0x5000`，去访问物理内存。
5.  进程完全不知道发生了什么，它以为自己真的读了 `0x1000`。

## 5.4 缺页异常：空头支票

有时候，进程想访问一个页面，但 MMU 发现页表里没有记录（或者标记为“不在内存中”）。
这时，MMU 会大喊一声：“停！出错了！” 这就是 **缺页异常 (Page Fault)**。

操作系统听到喊声，赶紧跑过来处理：
1.  **懒加载 (Lazy Allocation)**：进程申请了内存，但操作系统为了省事，先开个空头支票（只分配虚拟地址，不给物理页）。等进程真的要用了，触发缺页异常，操作系统才赶紧找一块物理页补上。
2.  **交换 (Swapping)**：内存不够了，操作系统把很久不用的页写到硬盘上（Swap 分区），腾出空间。等进程又要用时，再从硬盘读回来。

## 5.5 EwokOS 的内存管理

EwokOS 的内存管理代码主要在 `kernel/kernel/src/mm` 目录下。
它实现了基本的页表映射和内存分配 (`kmalloc`/`kfree`)。

每个进程都有自己的页目录 (`proc_t->space->vm`)。当切换进程时，内核会告诉 MMU：“换字典了！现在用进程 B 的页表。”

这样，进程 A 就算把自己的虚拟内存写烂了，也绝对影响不到进程 B 的物理内存。这就是**内存保护**。

下一章，我们将看看那些在用户空间辛勤工作的“打工仔”——驱动程序。
